<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何做一个好看的404界面</title>
      <link href="/2019/89541f63.html"/>
      <url>/2019/89541f63.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>hexo的是支持404界面的，使用起来很简单，只需要在hexo的source文件里面创建一个404.md 以及在主题的layout文件夹下创建一个404.ejs文件，然后想显示的内容直接填写在404.ejs里面就行了。<br>在404界面是在matery主题上做的，对于不同的主题方法类似，要根据具体的主题而定。</p></blockquote><blockquote><p>先展示一下效果：</p></blockquote><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/404-page/404.gif" alt="显示效果" title="显示效果"></p><h1 id="新建一个404-md文件"><a href="#新建一个404-md文件" class="headerlink" title="新建一个404.md文件"></a>新建一个404.md文件</h1><p>  在hexo的souce文件夹下创建一个404.md，之后输入如下内容：</p><pre class="line-numbers language-markdown"><code class="language-markdown"><span class="token hr punctuation">---</span>title: 404date: 2019-11-23 21:10:10type: "404"<span class="token title important">layout: "404"<span class="token punctuation">---</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  如下图所示：</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/404-page/1.jpg" alt="创建404.md" title="创建404.md"></p><h1 id="新建一个404-ejs文件"><a href="#新建一个404-ejs文件" class="headerlink" title="新建一个404.ejs文件"></a>新建一个404.ejs文件</h1><p>  在layout文件夹下创建404.ejs文件，可以在这里写入html，CSS和JS内容，也就是要在网页上进行显示的页面。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/404-page/2.jpg" alt="新建404.ejs文件" title="新建404.ejs文件"></p><p>  写入如下内容就可以在页面上显示404的内容了：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token comment" spellcheck="true">/* don't remove. */</span>    <span class="token selector"><span class="token class">.page404-cover</span> </span><span class="token punctuation">{</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">88</span>vh<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*页面高度*/</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 包含导航栏和页脚 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg-cover pd-header page404-cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col s10 offset-s1 m8 offset-m2 l8 offset-l2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>brand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title center-align<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        404                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description center-align<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        你要找的页面飞走了                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个页面不好看，所以我就在网上找到了一个比较好看的404页面，就是上面展示的那种，下面就讲解如何将这个页面嵌入到我们的网页中去。</p><h1 id="下载404特效"><a href="#下载404特效" class="headerlink" title="下载404特效"></a>下载404特效</h1><p>点击下载代码:<a href="https://www.lanrenzhijia.com/js/4285.html" target="_blank" rel="noopener">点我去代码出处</a></p><h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><h2 id="放入js文件到主题中"><a href="#放入js文件到主题中" class="headerlink" title="放入js文件到主题中"></a>放入js文件到主题中</h2><p>  将下载的压缩包解压，会发现里面有两个js文件和一个html页面，重要的就是js文件，将文件移植到主题的source文件的libs文件夹下，需要自己创建一个文件夹，我给文件夹取的名字叫做my404。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/404-page/4.jpg" alt="移动js文件" title="移动js文件"></p><h2 id="导入js文件"><a href="#导入js文件" class="headerlink" title="导入js文件"></a>导入js文件</h2><p>  <font color="red">因为该主题的js文件都是写_config.yml文件里面的，为了规范，也需要将文件的路径写到该文件夹下</font></p><p>  如下，之后导入js文件的时候就可以使用my404bodymovin和my404data来代替了</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/404-page/5.jpg" alt="写入路径" title="写入路径"></p><p>  现在可以打开404.ejs文件开始移植该特效了。</p><h2 id="编辑404-ejs文件"><a href="#编辑404-ejs文件" class="headerlink" title="编辑404.ejs文件"></a>编辑404.ejs文件</h2><p>  在该文件里面写入如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token comment" spellcheck="true">/* don't remove. */</span>    <span class="token selector"><span class="token class">.page404-cover</span> </span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* height: 75vh; */</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">88</span>vh<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector"><span class="token id">#svgContainer</span> </span><span class="token punctuation">{</span>      <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>      <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>      <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>      <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>&lt;script src="<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">theme.libs.js.my404bodymovin</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token script language-javascript">"<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>&lt;script src="<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">theme.libs.js.my404data</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token script language-javascript">"<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg-cover pd-header page404-cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>svgContainer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> svgContainer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'svgContainer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> animItem <span class="token operator">=</span> bodymovin<span class="token punctuation">.</span><span class="token function">loadAnimation</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          wrapper<span class="token punctuation">:</span> svgContainer<span class="token punctuation">,</span>          animType<span class="token punctuation">:</span> <span class="token string">'svg'</span><span class="token punctuation">,</span>          loop<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>          animationData<span class="token punctuation">:</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>animationData<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  现在就移植成功了，使用下面命令上传，之后输入一个错误的页面就可以查看到了</p><pre class="line-numbers language-hexo"><code class="language-hexo">hexo cl && hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PS:不要再本地试验，本地的时候输入错误的页面不会显示404页面的。<br><font color="blue">对页面显示的宽和高是可以进行调整的，最开始不是100%，我是为了美观改成了100%，直接调整选择器svgContainer里面的内容就行了</font></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>由于我把该主题的图片显示的遮罩去掉了，导致显示404页面的时候导航栏的文字看不见，因为字是白色的，所以需要修改导航栏的字体颜色，但是有不希望修改全局的主题颜色，所以就在该404.ejs文件夹下加入几个CSS选择器内容就行修改就行了。如下所以，加入如下内容即可：</p><pre class="line-numbers language-CSS"><code class="language-CSS">    header .brand-logo .logo-span {      color: #222;    }    header .nav-menu li i {      color: #222;    }    header .nav-menu li span {      color: #222;    }    header .button-collapse i {      color: #222;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017贸泽智造大赛-手势控制机械臂</title>
      <link href="/2019/fbbdec93.html"/>
      <url>/2019/fbbdec93.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是2017年的时候参加的贸泽电子智造大赛的时候发布的帖子，当时得了一个三等奖，😄。<br><a href="http://www.cirmall.com/bbs/thread-99386-1-1.html" target="_blank" rel="noopener">点我查看原链接</a><br>该比赛有许多优秀的作品，点击后面的连接进行跳转：<a href="http://www.cirmall.com/bbs/forum.php?mod=viewthread&amp;ordertype=2&amp;tid=99672" target="_blank" rel="noopener">点我查看优秀的项目</a></p></blockquote><h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><p>  本系统是采用CC3220s与LPC54608制作的手势控制的机械臂系统。可以完成通过简单的手势对机械臂的控制。手势识别指令采用的是MPU6050以及CC3220S自带的BMA222加速度计组合采集的。CC3220S作为手势端，将采集到的角度值进行分析、滤波、修正之后通过蓝牙发送给LPC54608，其中LPC54608作为控制端，与舵机相连，接收手势命令，通过滤波、限幅与消抖之后控制舵机，进而完成机械臂的运动。通信采用蓝牙进行，CC3220S将需要传输的数据进行处理封装、打包，通过串口进行发送，LPC54608将接收到的数据进行解析，防止出错。近实物验证，功能能够实现。</p><h1 id="作品实物"><a href="#作品实物" class="headerlink" title="作品实物"></a>作品实物</h1><h2 id="整体系统"><a href="#整体系统" class="headerlink" title="整体系统"></a>整体系统</h2><p>   在这些行图中，包含了整个系统的组成图片（4自由度机械臂，LPC54608，CC3220S，MPU6050，蓝牙模块等）</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131054nll1cbljcmaljmmq.png" alt="整体图片" title="整体图片"></p><h2 id="CC3220S的用处"><a href="#CC3220S的用处" class="headerlink" title="CC3220S的用处"></a>CC3220S的用处</h2><p>   CC3220S采集MPU6050与BMA222的数据，进行转换，封装。然后通过蓝牙模块发送出去，其中用到的模块都有标注，LED灯组用来显示连接状态，绿灯与黄灯表明IIC通信是都正常，在正常情况之下常亮，当IIC拦截不正常时会熄灭。红色的LED用来标志状态（<font color="blue">LED说明：此LED有三种闪烁状态，机械臂动作时闪烁周期是1秒，机械手动作时闪烁周期是2秒，空闲阶段闪烁周期是3秒</font>），开关用来进行不同功能的控制转换（开关用途：本来机械臂的机械手是想通过弯曲度传感器来进行识别的，弯曲传感器实际上是一种可变电阻，不同的弯曲度的电阻值不一样，通过采集AD值既可以进行弯曲度的识别了，但是目前在实习，弯曲传感器放在了学校忘带，所以在这里我就<font color="blue">采用了mpu6050来才做，然后用图中所示的开关进行模式切换，区别是控制机械臂还是控制机械手</font>）。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131056nox0kok052od1xm9.png" alt="CC3220S" title="CC3220S"></p><h2 id="LPC54608的作用"><a href="#LPC54608的作用" class="headerlink" title="LPC54608的作用"></a>LPC54608的作用</h2><p>   LPC54608接受来自CC3220S的数据，结果解析出具体角度数据，然后通过各种数据处理将数值转换成舵机控制数据，控制舵机的转动。同时液晶屏会实时显示接收到的数据，方便调试工作。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131058k7t5mjv7t7vyr4rx.png" alt="LPC54608" title="LPC54608"></p><h2 id="机械臂"><a href="#机械臂" class="headerlink" title="机械臂"></a>机械臂</h2><p>  机械臂采用了4自由度的小型机械臂，控制舵机的型号是MG90S（控制力度太小，灵敏度太低，别问我为什么选择这个机械臂，想着下学期就要毕业了，提前到公司实习一下，结果这一实习，直接就要吃土了，省吃俭用，靠着蚂蚁花呗才买了一个这个机械臂，没办法呀，自己挖的坑，怎么也得跳进去呀，只能将就着用这个机械臂了。这里还要吐槽一下，组装机械臂花了半天也就算了，调试的时候花了n天，力度还小的不行，灵敏度也特差，小范围的值变动根本就不动作，只能将就着用了）</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131100n6zvhavp86xh9az6.png" alt="机械臂" title="机械臂"></p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>  放上一些在软件调试过程中的一些图片</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131101q44oohlrrs0ukrkr.png" alt="调试过程" title="调试过程"></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131101zybtat3z48e39mj9.png" alt="调试过程" title="调试过程"></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131102b6zd93ddmze30qdr.png" alt="调试过程" title="调试过程"></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/14/131103m0f8djgjgobtd3f4.png" alt="调试过程" title="调试过程"></p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>演示视频以前是存在优酷的，但是现在貌似都访问不了了。</p><ol><li>手势控制端CC3220S组成及介绍</li></ol><p>说明：本来这个系统是应该直接待在手上的，但是由于体积有点大，带上之后不好操作，而且我也没有手套。所以我就直接拿着拿着演示了。<br><a href="http://player.youku.com/player.php/sid/XMzM5NTE1ODM4MA==/v.swf" target="_blank" rel="noopener">http://player.youku.com/player.php/sid/XMzM5NTE1ODM4MA==/v.swf</a></p><ol start="2"><li>机械臂控制端LPC54608组成及介绍</li></ol><p>说明：这是LPC54608的控制演示，图中可以看到屏幕显示接收到的数据，只有成功接收后才会显示数据，数据不正确的话是不会读取的，会直接跑跑去不解析。<br><a href="http://player.youku.com/player.php/sid/XMzM5NTE2Mzg5Mg==/v.swf" target="_blank" rel="noopener">http://player.youku.com/player.php/sid/XMzM5NTE2Mzg5Mg==/v.swf</a></p><ol start="3"><li>系统工作演示</li></ol><p>说明：这是系统工作时的演示视频。从视频中可以看出机械臂运动的不是很流畅，其实硬件原因占很大一部分，前面已经说过了，买的这个机械臂我也很后悔，但是没办法，这能将就着调试。这个械臂的最大的缺点就是灵敏度太差，所以会出现运动不流畅的现象，其次就是力度太小，稍微受电力就会出现不能运动的现象。当然，说了这么多，具体的原因还是在我自己。<a href="http://player.youku.com/player.php/sid/XMzM5NTE4ODY3Mg==/v.swf" target="_blank" rel="noopener">http://player.youku.com/player.php/sid/XMzM5NTE4ODY3Mg==/v.swf</a></p><ol start="3"><li>系统工作演示</li></ol><p>说明：这个视频看看就行<br><a href="http://player.youku.com/player.php/sid/XMzM5NTE3NjA0NA==/v.swf" target="_blank" rel="noopener">http://player.youku.com/player.php/sid/XMzM5NTE3NjA0NA==/v.swf</a></p><h1 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h1><p>由于文件大小大于了规定大小，所以采用了百度云上传的文件</p><p>链接：<a href="https://pan.baidu.com/s/1htn39sS" target="_blank" rel="noopener">https://pan.baidu.com/s/1htn39sS</a>     密码：7pl5</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LPC54608 </tag>
            
            <tag> CC3220S </tag>
            
            <tag> 机械臂 </tag>
            
            <tag> 串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涂鸦TYDE3.0开发板开箱与程序下载</title>
      <link href="/2019/60f07f02.html"/>
      <url>/2019/60f07f02.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> 涂鸦TYDE3.0是一块基于物联网的开发板，2018年的时候在爱板网上试用申请的。查看原网址：<a href="http://www.cirmall.com/bbs/thread-99261-1-1.html" target="_blank" rel="noopener">点我跳转查看原帖</a></p></blockquote><h1 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h1><p>  直接上图。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/06/111820ds6ii4vq8iyihzsy.png" alt="正面" title="正面"></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/06/111823m3x4b442bvv6jt62.png" alt="反面" title="反面"></p><p>  开发板的结构很简介明了，给人看到的第一印象是好多引脚，结果仔细一看，有三组的引脚都是下载口，可以支持多种下载模式。还有wifi模块也很显眼。<br>  另外还有一个USB口，一个RGB彩色灯，两个复位按键，两个BOOT按键以及连个用户自定义按键。<br>  3个LED灯。这些都是传统的物联网开发板的标配，但是有一点很好地就是没有引脚在旁边都给了名字说明，不用再胡原理图一个一个的找对应的引脚了，有时候找一个引脚真的很头疼。</p><p>  开发板的背部的设计简单明了。整个开发板给人的印象还不错，在加上STM32的主控，对于多数的物联网开发已经足够，运行速度也能得到保障。</p><h1 id="例程下载"><a href="#例程下载" class="headerlink" title="例程下载"></a>例程下载</h1><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>  到官网下载必要工具。</p><p><a href="https://docs.tuya.com/cn/mcu/download.html" target="_blank" rel="noopener">点我跳转到官网下载</a></p><p>  反正我将这个页面能下载的都下载了一遍。说一说必要下载的工具，看下图。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105303lhf7hah060abd3dh.png" alt="必要的工具" title="必要的工具"></p><p>  安装Flash Loader Demo，这个过程很简单，一路next就行了。然后将下载的名为1476783423-tuya_dev_demo_v3的压缩包解压就是我们要下载的官方最开始的例程。</p><h2 id="下载工具下载程序"><a href="#下载工具下载程序" class="headerlink" title="下载工具下载程序"></a>下载工具下载程序</h2><p>  参考 <a href="http://www.eeboard.com/bbs/thread-98467-1-1.html" target="_blank" rel="noopener">http://www.eeboard.com/bbs/thread-98467-1-1.html</a> 这个帖子，挺详细的。</p><p>1、首先是跳线帽的链接。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105304v3pzfrubuh5hurcb.png" alt="跳线帽连接" title="跳线帽连接"></p><p>  先按住BOOT，再按住RESET,然后先松开RESET，再松开BOOT就可以进行下载模式了，不行的话就多试几次。<br>  知道能不能下载的最重要的一点就是打开Flash Loader Demo，点击NEXT，看看会不会出现下面的界面。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105304v3pzfrubuh5hurcb.png" alt="未连接界面" title="未连接界面"></p><p>  如果卡住的话就不行再试一次，直到正常进行下一页面。一般情况下操作正常就可以正常下载了。</p><p>2、然后一路NEXT，选择下载的bin程序</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105305xv136usvka3yykkb.png" alt="选择bin文件" title="选择bin文件"></p><p>3、点击NEXT，等待几十秒就会下载成功</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105306ke2202f6a220za3o.png" alt="程序下载中..." title="程序下载中..."></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105306sz3cccczfxmzfzjc.png" alt="程序下载完成" title="程序下载完成"></p><h2 id="使用keil下载下载程序"><a href="#使用keil下载下载程序" class="headerlink" title="使用keil下载下载程序"></a>使用keil下载下载程序</h2><p>1、打开例程</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105656iururgtx9vpxjnj0.png" alt="选择例程" title="选择例程"></p><p>2、安装ST_link驱动程序</p><p>  我在网上随便下载了一个win版本的，可以正常使用，直接安装好了就行。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/105937tatrnj4qtt7a2ju8.png" alt="选择ST-Link安装包" title="选择ST-Link安装包"></p><p>3、打开工程</p><p>  如果没有安装stm32f103xxx的pdf的话就会自动弹出选择安装，直接默认安装就可以了，这个过程会比较慢，大概会等十几分钟。</p><p>  然后执行下面过程，重要</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/110350hao2a33u3ufcc8c1.png" alt="选择下载器" title="选择下载器"></p><p>3、现在就可以成功下载了，按如下方式操作</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/110552zs9kq9t7qkrfr7pz.png" alt="下载" title="下载"></p><p>  可以看到已经在正常下载了。<br>  注意：使用ST-Link下载需要一个ST-Link下载器</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201802/18/111034wd1ovfbbfs4b98fb.png" alt="下载软件" title="下载软件"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 涂鸦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LPC54608 </tag>
            
            <tag> 串口 </tag>
            
            <tag> Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LPCXpreso54608开箱运行与keil下的例程烧写</title>
      <link href="/2019/a44af509.html"/>
      <url>/2019/a44af509.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>LPCXpresso54608是一块功能十分强大的处理器，加上丰富的外设，可玩性很高，并且板载了4.3寸的液晶屏，本文讲述了使用keil对该开发板进行开发的准备工作以及程序下载。<br>最开是的帖子是发布在爱板网的。<a href="http://www.cirmall.com/bbs/thread-98217-1-1.html" target="_blank" rel="noopener">点我跳转到爱板网查看原帖</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  恩智浦的LPCXpresso54608开发板，外观看起来非常好看，搭载一块4.3寸的液晶屏。</p><p>  通过了解，LPPCXpresso54608新一代基于ARM Cortex-M4的LPC546x系列高性能微控制器。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104232z9no27mu1wi7oukn.png" alt="板卡说明" title="板卡说明"></p><p>  插上电源线，可以看到板载的例程，例程可玩性还是很高的，可以体验到一些此开发板的性能。在例程中，我们可以看到，在使用了华丽的界面的情况之下，CPU的占用率依然很低，由此可见你这块开发板的性能。</p><h1 id="资料收集"><a href="#资料收集" class="headerlink" title="资料收集"></a>资料收集</h1><p>  现在玩过了开发板的板载程序之后，就是着手的实际操作了。但是第一次用NXP的开发板，还是不知道该从哪个地方着手。</p><p>  先去官网逛一圈，登上恩智浦的官方网站：<a href="http://www.nxp.com" target="_blank" rel="noopener">http://www.nxp.com</a><br>  然后搜索LPCXpresso54608就可以找到这块开发板的资料,链接如下：<a href="https://www.nxp.com/cn/support/developer-resources/hardware-development-tools/lpcxpresso-boards/lpcxpresso-development-board-for-lpc5460x-mcus:OM13092?lang=cn" target="_blank" rel="noopener" title="点我跳转">点我跳转</a></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104243d75vqszjjbp52x91.png" alt="官网界面" title="官网界面"></p><p>  在软件和工具中可以找到该开发板的各种软件工具。</p><p>  官网中还有快速入门视频教程，有三个视频，但是一般加载不了，只能加载一点，估计是网站在国外的原因，使用vpn应该可以，但是视频也是英文的，对于我这种英文渣来说，一句都听不懂。</p><h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>  后面提供了工具的下载链接。<a href="https://www.nxp.com/cn/support/developer-resources/hardware-development-tools/lpcxpresso-boards/lpcxpresso-development-board-for-lpc5460x-mcus:OM13092?tab=Design_Tools_Tab" target="_blank" rel="noopener" title="点我跳转">点我跳转</a></p><p>  下面就是需要的开发工具</p><p>  1、开发IDE有三种：官方的MCUXpresso，IAR， keil<br>由于以前没有使用过MCUXpresso，使用过IAR（飞思卡尔k60）和keil（52单片机和STM32），其中对keil使用比较熟悉，所以我就选择了keil<br>  2、SDK：SDK_2.3.0_LPCXpresso54608这个肯定是不可或缺的，其中包含很多例程。<br>  3、MCUXpresso Config Tools：引脚配置工具。<br>  4、使用第三方的开发软件还要用到LPCSCRYPT，下载下来直接安装就可。</p><h1 id="Keil开发环境搭建"><a href="#Keil开发环境搭建" class="headerlink" title="Keil开发环境搭建"></a>Keil开发环境搭建</h1><h2 id="SDK下载"><a href="#SDK下载" class="headerlink" title="SDK下载"></a>SDK下载</h2><p>  keil软件在这里就不过多的介绍了，不会用的自行百度或者使用其他的开发工具（IAR或者MCUXpress）</p><p>  PS：在这里不得不多说一句，一定要使用keil uVision5，低版本的不支持嵌入式的开发板。</p><p>  将下载的SDK解压大一个目录中，方便使用。我是解压到了D:\nxp\SDK_2.3.0_LPCXpresso54608</p><h2 id="keil依赖包安装"><a href="#keil依赖包安装" class="headerlink" title="keil依赖包安装"></a>keil依赖包安装</h2><p>（1）、点击pack installer，一般在中间位置</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104243rhg38eacht22e2aq.png" alt="依赖包安装" title="依赖包安装"></p><p>（2）、在Devices下的搜索框中输入lpc，可以快速搜索到</p><p>（3）选择LPC54000 Series</p><p>（4）在Packs可以看到有Keil：：LPC54000_DFP,就就是安装这个包，点击右面的Install就行安装，慢慢等待，一般国内的网都比较慢。可能还会出现无法连接的情况，多试几次，我就是试了好几次才成功安装的。</p><p>（5）安装好了之后图标就会变成绿色，如下图所示：</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104244yi4s8cy0dszjtdzt.png" alt="安装完成" title="安装完成"></p><h2 id="例程运行"><a href="#例程运行" class="headerlink" title="例程运行"></a>例程运行</h2><p>  上面安装好了以来软件包了之后，就可以进行开发了。是不是有点小激动。打开keil，点击File–&gt;Open,或者直接ctrl+O打开一个文件<br>D:\nxp\SDK_2.3.0_LPCXpresso54608\boards\lpcxpresso54608\demo_apps\hello_world\mdk<br>  我选择的是hello_world，一般都是从  “你好，世界” 开始的，嘿嘿。</p><p>  <font color="red">注意：这是一个串口程序，需要提前准备一个串口软件。也可以选择其他例程。</font></p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104245qbebgcoe6o9sbobr.png" alt="SDK程序的选择" title="SDK程序的选择"></p><p>  一定要选择后缀名为<em>.uvproj,</em>.uvprojx 或者 *，不然的话什么都看不见，然后选择hello_world.uvprojx打开。</p><p>  点击Build和rebuild进行编译链接</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104245qyuzuad36q9z36yq.png" alt="编译和链接程序" title="编译和链接程序"></p><h2 id="下载设置"><a href="#下载设置" class="headerlink" title="下载设置"></a>下载设置</h2><p>  打开Options for Target….，然后选择Debug，如图所示：</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104246wbxqiehqgllb4qlg.png" alt="下载方式设置" title="下载方式设置"></p><p>  点击Settings，发现CMSIS-DAP下什么都没有。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104246pbwbk1kkjjawwzax.png" alt="没有下载器" title="没有下载器"></p><p>  可以查看官方的文档，是因为要将跳线帽去掉才可以进行选择，将如图所示的跳线帽去掉。</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104725z1nir1ddoxyxduf1.jpg" alt="官方文档找解决方案" title="官方文档找解决方案"></p><p>  跳线帽设置</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104247e9ldo7xiry37rz1n.png" alt="跳线帽设置" title="跳线帽设置"></p><p>  现在关闭Settings窗口在重新打开，会出现LPC-LINK2 CMSIS-DAP，现在就可以正常下载程序了。</p><p>  <font color="red">注意:USB线要插在Debug Link引脚，就是只有一个USB口的那个口。</font></p><p>  点击LOAD按钮进行程序的下载.</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104248bs4xi3ihecfqnzk2.png" alt="下载程序" title="下载程序"></p><p>  现在你会发现除了屏幕是白色的意外还是没有什么变化，还需要点一下开发板上的复位按钮，Target Reset按钮，即SW1按钮。然后打开一个串口调试助手。</p><p>  打开串口，然后发送一个字符串，开发板也会返回一个字符串</p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>  按照上面的方式完成相应的操作之后就可以开始正常的开发自己的程序了。</p><p>  下面是下载的例程的运行结果：</p><p><img src="http://www.cirmall.com/bbs/data/attachment/forum/201712/15/104249g7j6bbn6k7o6qru6.png" alt="运行结果" title="运行结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LPC54608 </tag>
            
            <tag> 串口 </tag>
            
            <tag> Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LPC双核挑战赛之餐厅服务机器人</title>
      <link href="/2019/45279adc.html"/>
      <url>/2019/45279adc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>LPC双核大赛是我还在本科阶段，大四的时候自己在网上看到的比赛，然后参加的。<br>当时是在NXP论坛上参加的，所以帖子也是发布在NXP论坛上的，可以通过后面的链接进入：<a href="http://www.nxpic.org/module/forum/thread-614243-1-1.html" target="_blank" rel="noopener">点我跳转到NXP社区查看该贴</a></p></blockquote><blockquote><p>这次比赛还是有不少的网友参加的，做的项目都挺不错，值得好好学习。点击后面的链接查看其他网友的项目：<a href="https://www.nxpic.org/activity/LPCcontest/vote" target="_blank" rel="noopener">点我跳转到双核大赛汇总区</a></p></blockquote><h1 id="一、项目名称"><a href="#一、项目名称" class="headerlink" title="一、项目名称"></a>一、项目名称</h1><pre><code>餐厅服务机器人</code></pre><p>下图是整体图片，请忽略它的外观，😄，太丑了</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/200104h3yu8u5iommrpudu.png" alt="项目整体图" title="项目整体图"></p><h1 id="一、项目概述"><a href="#一、项目概述" class="headerlink" title="一、项目概述"></a>一、项目概述</h1><p>  该项目是基于LPC54114双核芯片的餐厅服务机器人的设计。</p><p>  项目功能：通过该设计，当有人在桌子上坐下时，接触开关检测到之后会通过ESP8266发送信息到服务器，服务器会传输信息到机器人，机器人通过电磁传感器寻迹到达指定的服务桌子为客人提供服务。餐厅服务机器人有红外避障传感器，人体红外传感器可以进行避障，有语音播放模块可以播放预先设定的语音提醒客人的操作，与服务器的通信使用ESP8266 WIFI模块。该设计中有一块OLED显示屏为可以方便客人点餐，会自动计算价格上传服务器，并且在此过程中可以随时再点菜。通过最终的测试，机器人可以完成基本的实现预定的服务功能，细节部分还有待改进。</p><p>  项目特点：该项目使用到了双核系统，M4内核用于进行ESP8266与服务器的通信，OLED液晶显示，点菜操作，处理一些较为复杂的功能；M0+内核用于机器人的运动，语音播放，避障等功能，两个核之间通过mailbox中断进行数据通信。</p><p>  该项目包括单片机软件，服务器软件，服务器软件通过易语言编写。整个系统的硬件部分均采用了模块和手工焊接的方式来搭建完成的，软件部分通过MDK5调试完成。</p><h1 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h1><h2 id="1-OLED显示"><a href="#1-OLED显示" class="headerlink" title="1 OLED显示"></a>1 OLED显示</h2><h3 id="OLED各个界面显示"><a href="#OLED各个界面显示" class="headerlink" title="OLED各个界面显示"></a>OLED各个界面显示</h3><p>  OLED会显示wifi连接信息，操作方式以及菜单等一些信息，如下图所示，该OLED是通过IIC总线进行驱动的，使用了软件IIC。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/151938t7szj5m5wkqj7m07.png" alt="Wifi连接中..." title="Wifi连接中..."></p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/151938g76ci9mgdc7m7xz6.png" alt="使用说明" title="使用说明"></p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201805/30/203623k9est5t8feo7t56v.png" alt="点菜显示界面" title="点菜显示界面"></p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/151939qi8lkcgtlmg0zwx9.png" alt="显示金额" title="显示金额"></p><h3 id="OLED接线"><a href="#OLED接线" class="headerlink" title="OLED接线"></a>OLED接线</h3><p>  使用了IIC控制的OLED模块，IIC与GPIO的接线<br>SCL – PIO023<br>SDA – PIO024</p><h2 id="2-电磁轨道循迹"><a href="#2-电磁轨道循迹" class="headerlink" title="2 电磁轨道循迹"></a>2 电磁轨道循迹</h2><h3 id="电磁传感器"><a href="#电磁传感器" class="headerlink" title="电磁传感器"></a>电磁传感器</h3><p>  由于最近学校有恩智浦智能车大赛，有电磁组的赛道，所以我就直接使用电磁组的赛道用于餐厅服务机器人的寻迹，相比较于传统的黑线寻迹的优势很明显，不受环境光线的干扰，同时在运动过程中不容易出错，放在车子的最前端，由于标志桌子座位号还是采用了黑线，使用电磁传感器需要铺设特定的路径，没有此条件，所以用了一个红外避障传感器用于编辑是否到达指定的桌子座位号。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201805/30/203625few4w4679z9xqdjl.png" alt="电磁传感器" title="电磁传感器"></p><h3 id="放大器"><a href="#放大器" class="headerlink" title="放大器"></a>放大器</h3><p>  电磁传感器读取的是ADC值，但是，通过放大器进行放大，放大器将采集到的微弱信号放大到0-3.3V可以使用MCU拿来使用。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/154816iq46kupxddzqukzk.png" alt="电磁传感器放大器" title="电磁传感器放大器"></p><h3 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h3><p>  使用了2路电磁传感器，接线如下所示：<br>OUT1 – PIO1.1<br>OUT2 – PIO1.2</p><h2 id="3-ESP8266无限通信模块"><a href="#3-ESP8266无限通信模块" class="headerlink" title="3 ESP8266无限通信模块"></a>3 ESP8266无限通信模块</h2><p>  通过ESP8266与服务器连接。与服务器通信，服务器会发送“取菜”，“送菜”，“桌位号”等命令，客户端会接受这些命令，会发送菜单命令等。<br>  ESP8266通过串口用AT指令进行工作，串口发送指令给ESP8266，ESP8266再将指令通过WiFi发送出去，发送特殊的指令可以进行不同的操作。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201805/30/203625yvwvkkkqkkcnkk3k.png" alt="电磁传感器放大器" title="电磁传感器放大器"></p><p>PS：虽然是进行串口发送数据，但是这个串口的数据处理还是花了我很多的时间，最开始使用的是例程中的串口发送与接收程序，但是对ESP8266不适用，例程中的串口只能发送特定的为16的字符数据，有一个宏定义字符可以进行发送长度的修改，但是我试着修改了数据的长度，发现并没有用，而AT指令有时候大于这个数，并且发送指令也会大于这个成都，我的处理方式是进行分段发送，将一个很长的数据通过分段进行发送，通过最终的测试，数据可以正常的发送处理，可以发送任意长度的数据，通过对例程中的程序进行修改之后在进行发送长度的处理之后才能够就行数据的正常发送。</p><p>  该ESP8266是使用串口进行通信的，处理器与该芯片的连接方式如下：<br>  ESP8266使用的是串口5（USART5）<br>连线：<br>RXD – PIO0.20<br>TXD – PIO0.18</p><h2 id="4-自动避障功能的实现"><a href="#4-自动避障功能的实现" class="headerlink" title="4 自动避障功能的实现"></a>4 自动避障功能的实现</h2><p>  通过两个红外避障模块和一个人体红外模块进行避障功能，人体红外检测是否有人挡住了赛道，进行语音提醒。红外避障进行障碍物的避让，在路被挡住的情况下也可以进行简单避障运行。</p><p>  该模块使用起来比较简单，就是检测传感器返回的高低电平信号</p><p>接线：<br>第一个：PIO1.11<br>第二个：PIO1.10<br>第三个：PIO1.5</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201805/30/203624o0060a990ba82qa0.png" alt="红外避障模块" title="红外避障模块"></p><p>  当只有一个红外避障模块检测到障碍物的时候，就会自动避障，当两个红外避障模块同时检测到障碍物的时候就会启动蜂鸣器报警和语音提示借过一下。</p><h2 id="5-语音播放功能的实现"><a href="#5-语音播放功能的实现" class="headerlink" title="5 语音播放功能的实现"></a>5 语音播放功能的实现</h2><p>  当可以点菜时进行语音提示，点餐完毕进行语音提示，有人挡住障碍物进行语音提示。语音播放模块如下图。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201805/30/203623nvkuvgikosutjjub.png" alt="语音播放模块" title="语音播放模块"></p><p>  该语音播放模块采用的是蓝马科技的语音录放模块，其共有8个通道，每个通道控制一个语音，当给一个低电平的时候就会触发语音播放，控制方式建较为简单，由于我所控制的语音较少，所以就直接采用的单片机的IO口进行控制，如果控制得我语音较多的时候可以采用译码器进行控制。</p><p>接线：<br>第一段：PIO0.15<br>第二段：PIO0.19<br>第三段：PIO0.21</p><h2 id="6-主控"><a href="#6-主控" class="headerlink" title="6 主控"></a>6 主控</h2><p>  主控模块为lpc54110，由于我多次操作不当，这块单片机已经损坏了很多，第一个micro-USB口已经不能供电了，经过测试，是板载的KL26二极管坏掉了，我就采用的micro-USB2进行供电的，又一次不小心将小车从高空中摔落， 麦克风孔与耳机孔就壮烈牺牲了。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/152813niyoffipa1mmimgz.png" alt="主控模块" title="主控模块"></p><p>  本设计采用的双核进行工作，M0+核主要负责机器人的运动，采集电磁传感器的信号，处理并控制小车的运动，其中机器人是否运动则由M4核传输过来的控制信号决定，M4内核会传输送菜，取菜，有客人来了，停止，运动等信号。双核的信号通过MailBox中断进行，其中主要内核为M4。</p><h2 id="7-自制的服务器软件"><a href="#7-自制的服务器软件" class="headerlink" title="7 自制的服务器软件"></a>7 自制的服务器软件</h2><p>  该项目需要一个服务器软件参与控制，网上虽然有服务器软件，但是都不和我意，所以我就自己做了一个服务器软件。采用易语言编写，因为易语言见简单，中文编写。哈哈，下面就是我写的服务器软件的截图。<br>  我将所有的控制都设置成了按钮的形式。并且菜单也展示了出来，当接收到机器人发送过来的菜单信息时，马上对菜单进行分析，提取出客人所点的菜的信息，显示在最左边。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/153104ji74zzn44fahre4h.png" alt="服务器界面" title="服务器界面"></p><p>  菜名变成了绿色，表示客人点过这个菜了。如下图。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/153333mdbszwceeb0b44qn.png" alt="服务器界面" title="服务器界面"></p><h2 id="8-按键"><a href="#8-按键" class="headerlink" title="8 按键"></a>8 按键</h2><p>  该项目用到了lpc54110开发板上的板载的4个按键</p><ul><li>按键1：用于停止和启动M0+内核，由于主内核为M4，设置了一个按键用于对从内核的+ 汽艇进行控制；</li><li>按键2：用于控制菜单选择时的下一个菜名的选择；</li><li>按键3：用于菜单选择时的上一个菜名的选择；</li><li>按键4：单击用于进入菜单选择界面，选择某一个菜名，和再次进入菜单选择界面。</li><li>长按（大于2s）为确定选择的菜单信息并进行WIFI传送</li></ul><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><p>  该项目中用到了两个LED等，分别为LED7，LED6</p><ul><li>LED7为M0+内核的工作指示灯，没500ms闪烁一次</li><li>LED6为M4内核的工作指示灯，每隔1s中闪烁一次，当灯没有闪烁的时候表示内核没有工作或者程序卡死在哪个地方，在进行调试的时候非常有用，很多的时候M0+内核工作不正常都可以通过这种方式发现。</li></ul><h1 id="四、作品展示"><a href="#四、作品展示" class="headerlink" title="四、作品展示"></a>四、作品展示</h1><p>  整体如下图所示，有LPC54110双核单片机，12V电池，稳压模块，电机驱动，红外避障模块，人体红外模块，OLED 屏幕液晶，ESP8266模块，语音播放模块，蜂鸣器开关等期间组成：</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/152815l4wlytwzqyybqudy.png" alt="整体展示" title="整体展示"></p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/152815s2hhjbjbkjkuujje.png" alt="整体展示" title="整体展示"></p><p>  该项目几乎用到了lpc54110的所有IO口，不得不说的是IO口确实有点少。</p><p><img src="http://www.nxpic.org/module/forum/data/attachment/forum/201806/04/161924wafpe4mg3qn0nsna.png" alt="整体展示" title="整体展示"></p><h1 id="项目实现功能"><a href="#项目实现功能" class="headerlink" title="项目实现功能"></a>项目实现功能</h1><p>  1、当有客人在饭桌上坐下时，会发送一个命令“座位号：xx”到服务器，服务器接收到该命令就会再次将命令发送给机器人（该命令在本设计中是直接通过服务器发送的，直接进行模拟，本设计的重点是在餐厅服务机器人上，所以这部分只是进行了模拟）；<br>  2、机器人收到了“座位号：xx”命令就会自动运动到指定座位，然后停下，提示客人点餐，客人可以通过单片机上的OLED显示屏和按键选择所需要的菜名，然后确定之后发送给服务器；<br>  3、服务器收到机器人发送过来的菜单命令之后会自动解析出点的那些菜，并且在客人所点的菜的背景变成绿色，表示这个菜被客人所确定的；<br>  4、当厨师将才做好了之后会发送“取菜”命令，机器人获取到取菜命令之后会自动运动到厨房，然后停止，等待下一条指令；<br>  5、厨师将菜放好了之后，发送一个“送菜”命令，机器人获取到命令之后就会自动运动到客人座位旁边。<br>  6、然后依次循环，当客人走后，可以点击服务器上的清楚命令，恢复成初始值。</p><h1 id="五、视频演示"><a href="#五、视频演示" class="headerlink" title="五、视频演示"></a>五、视频演示</h1><p>不知道怎么了，以前的视频是上传到优酷的，但是现在好像访问不了了。<br>目前仅有一个ESP8266通信的视频，其他视频待整体组装之后拍摄<br><a href="http://player.youku.com/player.php/sid/XMzYzMzkxMDA0NA==/v.swf" target="_blank" rel="noopener">http://player.youku.com/player.php/sid/XMzYzMzkxMDA0NA==/v.swf</a></p><p>这个是完整的项目视频：<br><a href="http://player.youku.com/player.php/sid/XMzY0NTA3NDc5Ng==/v.swf" target="_blank" rel="noopener">http://player.youku.com/player.php/sid/XMzY0NTA3NDc5Ng==/v.swf</a></p><h1 id="六、项目文档"><a href="#六、项目文档" class="headerlink" title="六、项目文档"></a>六、项目文档</h1><p>关于代码，已经上传到了NXP论坛，感兴的话可以到该论坛上去下载：<br><a href="http://www.nxpic.org/module/forum/thread-614243-1-1.html" target="_blank" rel="noopener">http://www.nxpic.org/module/forum/thread-614243-1-1.html</a></p><h1 id="七、制作心得"><a href="#七、制作心得" class="headerlink" title="七、制作心得"></a>七、制作心得</h1><pre><code>通过几个月的设计与制作，该作品总算是初步完成了。最开始使用lpc54110芯片的时候，还不不太会操作，通过上论坛看了一些大神的帖子之后才慢慢明白了芯片的开发方式。由于一直使用keil进行单片机的开发，用的比较顺手，所以，这制作此项目的时候同样使用的是keil5。在项目往常的过程中，遇到过很多的问题，最后有一步一步的解决完成。最开始遇到的问题有硬件IIC驱动不去来，通过多次测试没有成功，最后切换成了软件IIC进行控制。还遇到了一些其他的问题，比如引脚驱动不起来，ADC值读取不出来等问题。通过软件与硬件结合的调试方式，最终这些问题都得以解决。对于本设计而言，外观确实比较简陋，甚至有点chou，也是出于无奈，学生党，没什么余钱，加上毕业在即，经济紧张，就用了一些以前的器件来制作的。该设计的软件与硬件方面都下了十足的功夫（不要以为他不好看就认为我在敷衍，其实打这个硬件也是花了一段时间的）。第一次使用双核开发板，还是挺有意思的，一块芯片集成了两个核，之间还可以进行通信，对于本设计而言也是很重要的，由于要求实时性，所以双核通信对于本设计用处非常大。最后说一下本兮比赛带给我的体验：1、获得了一块lpc54110开发板（虽然开发板现在已经残废了，USB1供不上电，以及麦克风插口和耳机插口掉了）；2、增加了自己的耐性，为了完成这次比赛我可以耐性十足呀，有时候一个问题硬是花了一天才解决（比如说ESP8266通信程序，由于是采用的串口通信，一些解析程序都是自己写的，这方面就足足花了我3天的时间，在整个过程中还在不断修改与完善）；3、增加了自己解决问题的能力，遇到了很多问题，有解决了很多问题；4、获得了经验，无论比赛的结果如何，总之收获了许多的经验。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OLED </tag>
            
            <tag> LPC54114 </tag>
            
            <tag> ADC </tag>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lpc11U68利用RTC实现闹钟小应用</title>
      <link href="/2019/9af07f43.html"/>
      <url>/2019/9af07f43.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>该文实现了时间的设置和显示，包括年月日，时分秒等，以及闹钟功能的实现，闹钟时间设置，蜂鸣器操作，OLED显示的等。<br>帖子以前是发送在NXP社区的。我也不想一篇一篇的移植了，就直接附上链接吧：<br><a href="http://www.nxpic.org/module/forum/thread-615806-1-1.html" target="_blank" rel="noopener">点我跳转到NXP社区查看lpc11U68的RTC如何使用</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OLED </tag>
            
            <tag> LPC11U68 </tag>
            
            <tag> RTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lpc11U68 RTC时钟芯片的使用</title>
      <link href="/2019/77fecb7c.html"/>
      <url>/2019/77fecb7c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>该文实现了时间的设置和显示，包括年月日，时分秒等，提供下详细的代码。<br>帖子以前是发送在NXP社区的。我也不想一篇一篇的移植了，就直接附上链接吧：<br><a href="http://www.nxpic.org/module/forum/thread-615759-1-1.html" target="_blank" rel="noopener">点我跳转到NXP社区查看lpc11U68的RTC如何使用</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LPC11U68 </tag>
            
            <tag> RTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lpc11U68 IIC控制OLED</title>
      <link href="/2019/9dbc05f0.html"/>
      <url>/2019/9dbc05f0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>帖子以前是发送在NXP社区的。我也不想一篇一篇的移植了，就直接附上链接吧：<br><a href="http://www.nxpic.org/module/forum/thread-615608-1-1.html" target="_blank" rel="noopener">点我跳转到NXP社区查看lpc11U68如何控制OLED</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OLED </tag>
            
            <tag> IIC </tag>
            
            <tag> LPC11U68 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lpc11U68串口控制RGB LED</title>
      <link href="/2019/d53273e5.html"/>
      <url>/2019/d53273e5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>该程序实现的功能是串口接受到一串数据之后，根据第一位数据来进行判断控制RGB LED，控制很简单，和按键控制并没有什么区别。</p></blockquote><blockquote><p>帖子以前是发送在NXP社区的。我也不想一篇一篇的移植了，就直接附上链接吧：<br><a href="http://www.nxpic.org/module/forum/thread-615527-1-1.html" target="_blank" rel="noopener">点我跳转到NXP社区查看串口如何控制LED</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口 </tag>
            
            <tag> LPC11U68 </tag>
            
            <tag> LED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lpc11U68上手体验及串口通信</title>
      <link href="/2019/b3f51bfe.html"/>
      <url>/2019/b3f51bfe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>LPC11U68是恩智浦推出的一块低功耗的单片机，对于其介绍就不多少了，可以点击跳转官网中查看：<a href="https://www.nxpic.org/page/LPC11U68" target="_blank" rel="noopener">点我跳转</a>。<br>LPC11U68单片机最开始是在NXP社区试用的，所以在恩智浦社区发布了试用分享。<br>点击跳转：<a href="http://www.nxpic.org/module/forum/thread-615519-1-1.html" target="_blank" rel="noopener">1开箱</a><br>点击调转：<a href="http://www.nxpic.org/module/forum/thread-615522-1-1.html" target="_blank" rel="noopener">2串口通信</a></p></blockquote><h1 id="资料搜集"><a href="#资料搜集" class="headerlink" title="资料搜集"></a>资料搜集</h1><h2 id="lpc11u68外观展示"><a href="#lpc11u68外观展示" class="headerlink" title="lpc11u68外观展示"></a>lpc11u68外观展示</h2><p>  如下图，这块板子做的还是挺好看的，大小就是一张身份证的大小，采用了Arduino的封装，可以直接与arduino的板子一起使用吧，同时还提供了芯片的引脚的位置，但是并没有焊接引脚，需要自己找排针焊接，我觉得官方应该提供排针的，不然这东西还真的不好找。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/LPC11U68_positive.png" alt="lpc11u68正面" title="lpc11u68正面"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/LPC11U68_negative.png" alt="lpc11u68反面" title="lpc11u68反面"></p><h2 id="资料搜集-1"><a href="#资料搜集-1" class="headerlink" title="资料搜集"></a>资料搜集</h2><p>  单片机开发最重要的就是要搜集资料，所以在开始开发之前是要搜集关于lpc11u68的资料。在这里汇集了很多网友试用的时候发布的帖子。<br>  <a href="http://www.nxpic.org/module/forum/thread-615222-1-1.html" target="_blank" rel="noopener">点我跳转到资料汇集页面</a></p><h1 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a>固件更新</h1><p>  主要去官网下载SDK包，原理图和KEIL软件。搜集完了必要的资料之后可以开始上手实践了。</p><p>  但是还是遇到了一些问题，找了一根数据线插上，准备下载程序的时候才发现电脑发现不了端口，然后在看了其他网友的帖子才发现是需要更新固件的原因。固件更新的方法也很简单。可以参考：<a href="http://www.nxpic.org/module/forum/thread-615218-1-1.html" target="_blank" rel="noopener">点我了解固件更新方法</a></p><p>  但是有一点需要注意：<font color="red">需要将JP1的跳线帽拔下来,短接JP3，才能够成功</font>最开始的时候没有拔掉JP1，导致一直更新不了。</p><p>  更新了成功了固件之后，就可以只用JLINK模式进行下载程序了，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/original.png" alt="LED程序演示" title="LED程序演示"></p><h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><blockquote><p>学习了一下按键，LED和串口，这些都在例程中就有的，调用的函数都在Broad.c这个函数里面，可以直接调用，还是比较方便的。按键和LED就不说了，这个是比较简单的，直接讲一下如何操作串口4。</p></blockquote><h2 id="串口通信函数"><a href="#串口通信函数" class="headerlink" title="串口通信函数"></a>串口通信函数</h2><p>  在例程中已经有了USB串口的发送和接收函数，就先说一下这两个函数的用法，看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/code1.png" alt="串口通信函数" title="串口通信函数"></p><p>  使用这两个函数可以方便的进行数据的传输和发送，可以用于调试。<br>接收到数据之后就马上返回到串口。</p><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p>  串口4的电路图如下面所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/circuit_diagram.png" alt="串口4引脚图" title="串口4引脚图"></p><p>  线路连接图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/wire_connect.png" alt="线路连接图" title="线路连接图"></p><h2 id="程序修改"><a href="#程序修改" class="headerlink" title="程序修改"></a>程序修改</h2><p>  对于串口4，我是用的是工具包中的程序改造的。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/tool_pack.png" alt="SDK路径" title="SDK路径"></p><p>  对于串口4，我是用的是工具包中的程序改造的。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/code2.png" alt="修改串口数" title="修改串口数"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/code3.png" alt="修改串口引脚" title="修改串口引脚"></p><p>  然后改造了函数，改造成了接收什么就返回给串口</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/code4.png" alt="修改串口通信方式" title="修改串口通信方式"></p><p>  完成上面的操作之后就可以进行正常的通信了。</p><h1 id="演示结果"><a href="#演示结果" class="headerlink" title="演示结果"></a>演示结果</h1><p>  下面是演示结果：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/uart_communication.png" alt="串口通信演示" title="串口通信演示"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上附件，已经创建好了工程，可以参考：<br><a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/lpc11U68/Uart_comm/LPC11U68_UART.zip" target="_blank" rel="noopener">点我下载附件</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LPC系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口 </tag>
            
            <tag> LPC11U68 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32使用之OLED显示屏驱动</title>
      <link href="/2019/65127458.html"/>
      <url>/2019/65127458.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>现在开始使用普中的STM32进行研究学习了，STM32的使用方式与51单片机还是有许多的相似之处的，但是STM32的功能更强大，ADC，定时器，flash等等，先不多说了，开始进入主题：使用IIC操作OLED进行显示。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  OLED相信大家都不陌生，这个显示器现在很流行，我现在使用的OLED显示屏就是12864的IIC操作的OLED，为什么选择使用IIC的呢？因为足够简单。IIC大家都知道，他的协议就不多说了，不会的小伙伴可以自行百度哦。</p><p>  我是用的是<font color="red">模拟IIC</font>，没有使用STM32的硬件IIC，传说STM32的硬件IIC是很大的BUG。具体我也不太清楚，反真是用模拟IIC操作起来也是一样的。</p><blockquote><p>以前发帖在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100342-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>  在操作之前，需要先了解STM32的引脚排布，在硬件IO扣上并没有标注引脚号，所以需要查看原理图，这点很不友好，应该在每个IO口旁边编著上引脚号，方便操作，不然每次都要查看一下原理图：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/yuanlitu.png" alt="原理图" title="原理图"></p><p>我选用的IIC驱动引脚是PB6和PB7。<br><font color="red" size="2"></font></p><font color="red" size="2"></font><ul><font color="red" size="2"><li>PB6–SCL</li></font><li><font color="red" size="2">PB7–SDA</font></li></ul><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="IIC引脚定义"><a href="#IIC引脚定义" class="headerlink" title="IIC引脚定义"></a>IIC引脚定义</h2><pre class="line-numbers language-C"><code class="language-C">//初始化IICvoid IIC_Init(void){                                                     GPIO_InitTypeDef GPIO_InitStructure;        //RCC->APB2ENR|=1<<4;//先使能外设IO PORTA时钟         RCC_APB2PeriphClockCmd(        RCC_APB2Periph_GPIOB, ENABLE );                GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   //推挽输出        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;        GPIO_Init(GPIOB, &GPIO_InitStructure);        IIC_SCL=1;        IIC_SDA=1;}/****  SDA输出**/void SDA_OUT(void){    GPIO_InitTypeDef GPIO_InitStructer;    GPIO_InitStructer.GPIO_Pin= GPIO_Pin_7;    GPIO_InitStructer.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_InitStructer.GPIO_Mode=GPIO_Mode_Out_PP;    GPIO_Init(GPIOB, &GPIO_InitStructer);}/****  SDA输入**/void SDA_IN(void){    GPIO_InitTypeDef GPIO_InitStructer;    GPIO_InitStructer.GPIO_Pin= GPIO_Pin_7;    GPIO_InitStructer.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_InitStructer.GPIO_Mode=GPIO_Mode_IPU;    GPIO_Init(GPIOB, &GPIO_InitStructer);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="OLED初始化"><a href="#OLED初始化" class="headerlink" title="OLED初始化"></a>OLED初始化</h2><pre class="line-numbers language-C"><code class="language-C">void OLED_Init(void){        delay_ms(500);        OLED_WrCmd(0xAE); //关闭显示        OLED_WrCmd(0xD5); //设置时钟分频因子,震荡频率        OLED_WrCmd(80);   //[3:0],分频因子;[7:4],震荡频率        OLED_WrCmd(0xA8); //设置驱动路数        OLED_WrCmd(0X3F); //默认0X3F(1/64)         OLED_WrCmd(0xD3); //设置显示偏移        OLED_WrCmd(0X00); //默认为0        OLED_WrCmd(0x40); //设置显示开始行 [5:0],行数.        OLED_WrCmd(0x8D); //电荷泵设置        OLED_WrCmd(0x14); //bit2，开启/关闭        OLED_WrCmd(0x20); //设置内存地址模式        OLED_WrCmd(0x02); //[1:0],00，列地址模式;01，行地址模式;10,页地址模式;默认10;        OLED_WrCmd(0xA1); //段重定义设置,bit0:0,0->0;1,0->127;        OLED_WrCmd(0xC0); //设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]->COM0;N:驱动路数        OLED_WrCmd(0xDA); //设置COM硬件引脚配置        OLED_WrCmd(0x12); //[5:4]配置        OLED_WrCmd(0x81); //对比度设置        OLED_WrCmd(0xEF); //1~255;默认0X7F (亮度设置,越大越亮)        OLED_WrCmd(0xD9); //设置预充电周期        OLED_WrCmd(0xf1); //[3:0],PHASE 1;[7:4],PHASE 2;        OLED_WrCmd(0xDB); //设置VCOMH 电压倍率        OLED_WrCmd(0x30); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;        OLED_WrCmd(0xA4); //全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏)        OLED_WrCmd(0xA6); //设置显示方式;bit0:1,反相显示;0,正常显示                                                                       OLED_WrCmd(0xAF); //开启显示         }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  上面只粘贴了部分程序：由于篇幅原因，代码我会上传附件。</p><h1 id="字模提取"><a href="#字模提取" class="headerlink" title="字模提取"></a>字模提取</h1><h2 id="取模工具"><a href="#取模工具" class="headerlink" title="取模工具"></a>取模工具</h2><p>  下面说一说中文字模的提取吧，如果要显示汉字的话，需要用工具进行取模。<br>  首先需要一个中文字模的提取软件，如果自己写字模的话，可是一件耗时的工程。</p><p>软件下载：<a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/OLED_Project.7z" target="_blank" rel="noopener">点我下载</a></p><p>  取模操作方式：<font color="blue" size="2">取字方式 – 共阴、逐列式、顺向输出</font></p><h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><p>1、打开软件</p><p>  如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/word_setting.png" alt="打开软件" title="打开软件"></p><p>2、选择取模方式</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/sample_method.png" alt="选择取模方式" title="选择取模方式"></p><p>3、生成汉字数组</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/generate_hanzi.png" alt="选择取模方式" title="选择取模方式"></p><p>》》最后将生成的代码复制到程序中就可以使用了</p><h2 id="汉字显示程序"><a href="#汉字显示程序" class="headerlink" title="汉字显示程序"></a>汉字显示程序</h2><p>  下面是显示汉字的程序。</p><pre class="line-numbers language-C"><code class="language-C">//在指定位置显示一个汉字//x:0~127//y:0~63                         //chr:汉字的索引//mode:0,反白显示;1,正常显示        void OLED_ShowHz(u8 x,u8 y,u8 chr,u8 mode){        u8 temp,t,t1;        u8 y0=y;        u8 csize=32;                //得到字体一个字符对应点阵集所占的字节数        chr=chr*2;//得到偏移后的值                     for(t=0;t<csize;t++)    {                   temp=Hz[chr][t];                for(t1=0;t1<8;t1++)                {                        if(temp&0x80)                                OLED_DrawPoint(x,y,mode);                        else OLED_DrawPoint(x,y,!mode);                        temp<<=1;                        y++;                        if((y-y0)==16)                        {                                y=y0;                                x++;                                break;                        }                }               }                   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：汉字字库（也就是刚才使用汉字生成工具生成的数据）的名字就是Hz[][16]。</p><h1 id="演示结果展示"><a href="#演示结果展示" class="headerlink" title="演示结果展示"></a>演示结果展示</h1><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/generate_hanzi.png" alt="演示效果" title="演示效果"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上程序：<a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/STM32-OLED/OLED_Project.7z" target="_blank" rel="noopener">点我下载STM32 OLED驱动程序</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OLED </tag>
            
            <tag> IIC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32使用之驱动流水灯</title>
      <link href="/2019/b1cecfb6.html"/>
      <url>/2019/b1cecfb6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>普中的这个开发板除了可以使用51单片机进行开发之外，还可以使用开发套件提供的STM32核心进行开发，提供的STM32的最小系统板采用的是STM32F103C8T6，这是一种最普片使用的低成本的STM32单片机。</p></blockquote><blockquote><p>以前发帖在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100338-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="STM32核心"><a href="#STM32核心" class="headerlink" title="STM32核心"></a>STM32核心</h1><p>  这个STM32的最小系统板长这样</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/STM32_core.jpg" alt="STM32核心" title="STM32核心"></p><p>  方向插对，之后就可以正常的进行开发了，从图中可以看到明显的J_LINK插口，可以方便的使用J_LINK进行程序的下载，但是一个J_LINK也是极贵的所，所以本文选择使用USB串口下载程序。</p><h1 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h1><h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p>  如下图所示，<font color="red">stm32最小系统上的RTS与DTR粉笔与开发板上面的RTS与DTR相连接</font></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/STM32_Download_Pin.jpg" alt="连接USB下载线" title="连接USB下载线"></p><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>  连接好后就可以通过USB下载程序了，与51单片机的使用方式是一样的，利用hex文件下载软件，直接下载hx文件吗，官方已经给我们提供了一个普中的下载软件。</p><p>  软件的名字叫做：PZ-ISP普中自动下载软件.exe，提供给你们附件如下，有需要的小伙伴可以下载使用.<br><a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/PZ-ISP_Download_tool.zip" target="_blank" rel="noopener">点我下载普中开发板下载器</a></p><h2 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h2><p>  具体的下载方式如下所示：<br>  <font color="red">这里还有以下是需要注意的，就是供电跳线帽要打到3.3V的位置，因为STM32是3.3V供电的，如果不改变跳线帽的话可能回烧坏stm32。</font></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/Download_setting.jpg" alt="下载方式" title="下载方式"></p><ul><li>打开下载器软件，连接USB线。</li><li>选择单片机型号，如下图所示；</li><li>选择串口，这个一般是不需要选择的，如果没有显示可用的串口的话，应该是驱动没有安装好，下载一个USB_ttl驱动安装就可以了；</li><li>选择波特率115200；</li><li>选择hex文件，编译程序生成的hex文件；</li><li>最后就是下载程序了，直接点击下载即可，在程序代码量比较下的时候，直接使用USB进行下载还是挺快的，但是当程序变得很大的时候，下载就会很慢，有可能还会达到几分钟。所以有JLINK的伙伴还是使用J_LINK进行下载吧。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/download_select.jpg" alt="选择单片机型号" title="选择单片机型号"></p><p>  程序下载好了就可以进行演示查看了，我选择的是流水灯的程序。直接使用的官方的流水灯程序。P0口连线如下：<br><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/wire_connect.jpg" alt="连线" title="连线"></p><p>emsp; 其实STM32的开发与51单片机的的开发还是比较相似的，只不过STM32的运行速度很快，而STM32还提供许多内置设备，如PWM，AD/DA等。还有一点就是STM32进行GPIO扣得初始化还是比较复杂的。</p><p>emsp; <font color="red" size="2">开发STM32必须使用KEIL5(MDK5)软件进行，并且软件是不内置芯片支持库的，需要自行安装，可以到官网去下载stm32f103的支持包就可以正常的编译程序了，不然程序只能查看是不能进行编译运行的。</font></p><h1 id="演示结果展示"><a href="#演示结果展示" class="headerlink" title="演示结果展示"></a>演示结果展示</h1><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/display1.gif" alt="演示效果" title="演示效果"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/display2.gif" alt="演示效果" title="演示效果"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上程序：<a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/stm32-Running_water_light/PZ-ISP_Download_tool.zip" target="_blank" rel="noopener">点我下载STM32流水灯程序</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机驱动DS1302实时时钟芯片</title>
      <link href="/2019/1a2482fe.html"/>
      <url>/2019/1a2482fe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>很多初学51单片机的小伙伴都喜欢用定时器作为时间模拟显示，这是可以的，对于精度要求不是很高的场合是可以使用的，但是当精度要求很高的时候，使用定时器就不定了，因为51单片机的定时器的精度本来就不高，我们可以使用常见的时钟芯片：DS1302来进行时间的显示。</p></blockquote><blockquote><p>DS1302会自动进行时间的自加，所以字需要写入初始时间就可以自动就行西东进行时间的获取了，不需要用户进行时间的处理。</p></blockquote><blockquote><p>DS1302可以针对年月日星期时分秒进行处理。我们在程序中通过数码管进行显示时间，由于数码管只有8个，所以时间与年月日信息分开显示，通过独立按键8进行转换。</p></blockquote><blockquote><p>以前发帖在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100332-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>  首先查看电路原理图，看开发板上的DS1302的引脚，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/DS1302.png" alt="DS1302原理图" title="DS1302原理图"></p><p>  本文中使用到了按键，按键的原理图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/key.png" alt="按键原理图" title="按键原理图"></p><p>  本文还使用到了数码管，之前写过数码管的驱动帖子，在这里就不做过多的介绍了，直接移步：<a href="http://hehung.top/archives/9ea6.html">点我移步数码管操作</a></p><p>  从上面的原理图中我们知道了使用到的器件的连线引脚定义如下：</p><pre class="line-numbers language-C"><code class="language-C">//DS1302时钟芯片引脚定义sbit sck=P3^6;sbit io=P3^4;sbit rst=P3^5;//数码管位选引脚定义sbit LA = P1^0;sbit LB = P1^1;sbit LC = P1^2;//按键引脚定义sbit KEY = P2^0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="DS1302"><a href="#DS1302" class="headerlink" title="DS1302"></a>DS1302</h1><h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><p>  DS1302的时序相对而言比较复杂，请看详细的资料文档说明：<br><a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/DS1302_chinese_manual.pdf" target="_blank" rel="noopener">点我下载DS1302中文手册</a></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>  如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/Sequence_diagram.png" alt="时序图" title="时序图"></p><p>  根据时序图来进行读/写字节，可以看到SCLX在由低变高就是写，由高变低就是读，连续读/写8个字节。</p><h2 id="时间操作寄存器"><a href="#时间操作寄存器" class="headerlink" title="时间操作寄存器"></a>时间操作寄存器</h2><p>  如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/registers.png" alt="时序图" title="时序图"></p><p>可以看到读/写都有不同的寄存器，每个寄存器代表了不同的日期信息，需要哪个日期就读/写哪个寄存器就行了。</p><h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>  下面是代码。</p><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>#include<intrins.h>#define uchar unsigned char#define uint unsigned int//DS1302时钟芯片引脚定义sbit sck=P3^6;sbit io=P3^4;sbit rst=P3^5;//数码管位选引脚定义sbit LA = P1^0;sbit LB = P1^1;sbit LC = P1^2;//按键引脚定义sbit KEY = P2^0;//数码管的数字//下面的数组可以显示0-Fuchar code smg_D[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,                                        0x7f,0x6f,~0xbf};uchar time_data[7]={18,4,4,13,11,59,50};                //年星期月日时分秒uchar write_add[7]={0x8c,0x8a,0x88,0x86,0x84,0x82,0x80};                //写地址命令uchar read_add[7]={0x8d,0x8b,0x89,0x87,0x85,0x83,0x81};                        //读地址命令uchar disp[8];void delay_ms(uint q){     uint w;         for(;q>0;q--)            for(w=110;w>0;w--);}void delay_us(uint q){         for(;q>0;q--);}void delay_nop(){    _nop_();        _nop_();        _nop_();        _nop_();        _nop_();}//该函数可以选择某一个数码管显示void change(int what){        switch(what)        {                case 1:LC=0;LB=0;LA=0;break;                case 2:LC=0;LB=0;LA=1;break;                case 3:LC=0;LB=1;LA=0;break;                case 4:LC=0;LB=1;LA=1;break;                case 5:LC=1;LB=0;LA=0;break;                case 6:LC=1;LB=0;LA=1;break;                case 7:LC=1;LB=1;LA=0;break;                case 8:LC=1;LB=1;LA=1;break;                        }}void reset() //重置{        rst=0;_nop_();        sck=0;_nop_();        rst=1;_nop_();}//写数据函数void write_data(uchar dat){    uchar i;        for(i=0;i<8;i++)        {            sck=0;                io=dat&0x01;                delay_nop();delay_nop();delay_nop();                dat>>=1;                sck=1;        }        }//写数据与命令函数void write_add_data(uchar add,uchar dat){    reset();        rst=1;        write_data(add);        delay_nop();         delay_nop();        write_data(dat);        rst=0;        _nop_();_nop_();_nop_();_nop_();        io=0;        sck=1;}//阅读数据函数uchar read_dat(uchar add){    uchar i,v;    reset();        delay_nop();        write_data(add);        for(i=0;i<8;i++)        {            v>>=1;                sck=0;            if(io)                        v|=0x80;                sck=1;                delay_nop();delay_nop();delay_nop();        }        rst=0;        sck=0;        delay_nop();                 sck=1;        io=1;        return v;}//设置时间函数void set(){   uchar i,j;   for(i=0;i<7;i++)   {        j=time_data[i]/10;                time_data[i]=time_data[i]%10;                time_data[i]=time_data[i]+j*16;                delay_nop();   }                                             write_add_data(0x8e,0x00);          //去除写保护   _nop_();   for(i=0;i<7;i++)   {        write_add_data(write_add[i],time_data[i]);                delay_nop();   }   write_add_data(0x8e,0x80);                           //加写保护}//于都时间函数void readtime(){        uchar i;        for(i=0;i<7;i++)        {            time_data[i]=read_dat(read_add[i]);                write_add_data(0x00,0x00);               //重点啊        }}//将时分秒处理方便显示void chuli()                //处理数据函数{    disp[0]=time_data[4]/16;        disp[1]=time_data[4]%16;          disp[2]=10;        disp[3]=time_data[5]/16;        disp[4]=time_data[5]%16;        disp[5]=10;        disp[6]=time_data[6]/16;        disp[7]=time_data[6]%16;}//将年月日处理方便显示void chuli1()                //处理数据函数{    disp[0]=time_data[0]/16;        disp[1]=time_data[0]%16;          disp[2]=10;        disp[3]=time_data[2]/16;        disp[4]=time_data[2]%16;        disp[5]=10;        disp[6]=time_data[3]/16;        disp[7]=time_data[3]%16;}//函数时分秒void display(){    uchar i;    for(i=0;i<8;i++)        {            change(i+1);                P0=smg_D[disp[i]];                delay_us(50);                 P0 = 0;                delay_us(10);         //消除暗影                    }}//主函数void main(){                           set();        while(1)        {            readtime();                display();                if(KEY == 0)                {                        chuli1();                //处理年月日                }else                {                        chuli();                //处理时分秒                }                }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="blue">注意：上述程序中，我是用按键8来进行年与日与时分秒的切换，按下按键8（P2.0引脚）就会显示年月日，放开就会显示时间。</font></p><h1 id="运行结果展示"><a href="#运行结果展示" class="headerlink" title="运行结果展示"></a>运行结果展示</h1><p>》时间显示效果</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/display2.jpg" alt="时间显示" title="时间显示"></p><p><font size="2">通过按按键8可以进行时间，日期的切换。</font></p><p>》日期显示效果</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/display3.jpg" alt="时间显示" title="时间显示"></p><p>》时间动态显示</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/display.gif" alt="时间显示" title="时间显示"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>附上程序：<a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS1302/DS1302_project.zip" target="_blank" rel="noopener">点我下载DS1302工程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> DS1302 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机驱动步进电机</title>
      <link href="/2019/1163adc9.html"/>
      <url>/2019/1163adc9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>拿到开发板还没有使用过电机与步进电机呢，但是电机的控制太简单了，在这里就不演示了，直接用IO口的高低电平就可以正常控制了，所以就来操作一下稍微难一点而的步进电机。以前发帖在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100298-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>  首先查看原理图。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-stepper_motor/Stepper_motor_Schematic.png" alt="原理图" title="原理图"></p><p>  从上面的原理图中可以看出，该步进电机是四线双极性步进电机，需要四根线控制。</p><p>  在开发板上的接线图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-stepper_motor/connect_to_micro_controller.jpg" alt="线路连接" title="线路连接"></p><h1 id="步进电机控制方式"><a href="#步进电机控制方式" class="headerlink" title="步进电机控制方式"></a>步进电机控制方式</h1><p>  这种步进电机可以正反转运动，同时还有三种控制方式：</p><p>1.单相四拍通电驱动时序<br>正转： A- B  A  B-<br>反转： B-  A  B  A-</p><p>2.双相通电四拍驱动时序<br>正转：A-B   AB   AB-  A-B-<br>反转：A-B-  AB-  AB   A-B</p><p>3.半步八拍驱动时序<br>反转：A-  A-B  B  AB  A  AB-  B-  A-B-<br>正转：A-B-  B-  AB-  A  AB  B  A-B  A-</p><p>  上面的控制原理中，A，A_，B，B_分别表示4根控制线。</p><h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>  下面是主要代码。</p><h2 id="单相四拍控制方式"><a href="#单相四拍控制方式" class="headerlink" title="单相四拍控制方式"></a>单相四拍控制方式</h2><p>是单相四拍方式,反转（逆时针），如果想正转，安装上方的工作顺序自行切换就可以了。</p><pre class="line-numbers language-C"><code class="language-C">#include "reg52.h"                        #define uchar unsigned char #define uint  unsigned intsbit SA = P1^0;sbit SA_ = P1^1;sbit SB = P1^2;sbit SB_ = P1^3;         #define time 2000 void step_Motor(void);void delay(uint ms);void step_Motor2(void);void step_Motor3(void);void main(){                while(1)        {                        step_Motor();                        }}void step_Motor(void){        SA = 1;        SA_ = 0;        SB = 1;        SB_ = 1;        delay(time);        SA = 1;        SA_ = 1;        SB = 1;        SB_ = 0;        delay(time);        SA = 0;        SA_ = 1;        SB = 1;        SB_ = 1;        delay(time);        SA = 1;        SA_ = 1;        SB = 0;        SB_ = 1;        delay(time);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双相通电四拍驱动时序"><a href="#双相通电四拍驱动时序" class="headerlink" title="双相通电四拍驱动时序"></a>双相通电四拍驱动时序</h2><p>  如下，只提供主要操作代码</p><pre class="line-numbers language-C"><code class="language-C">void step_Motor2(void){        SA = 1;        SA_ = 0;        SB = 1;        SB_ = 0;        delay(time);        SA = 0;        SA_ = 1;        SB = 1;        SB_ = 0;        delay(time);        SA = 0;        SA_ = 1;        SB = 0;        SB_ = 1;        delay(time);        SA = 1;        SA_ = 0;        SB = 0;        SB_ = 1;        delay(time);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="半步八拍（正转，顺时针）"><a href="#半步八拍（正转，顺时针）" class="headerlink" title="半步八拍（正转，顺时针）"></a>半步八拍（正转，顺时针）</h2><p>  如下，只提供主要操作代码</p><pre class="line-numbers language-C"><code class="language-C">void step_Motor3(void){        SA = 1;        SA_ = 0;        SB = 1;        SB_ = 0;        delay(time);        SA = 1;        SA_ = 1;        SB = 1;        SB_ = 0;        delay(time);        SA = 0;        SA_ = 1;        SB = 1;        SB_ = 0;        delay(time);        SA = 0;        SA_ = 1;        SB = 1;        SB_ = 1;        delay(time);        SA = 0;        SA_ = 1;        SB = 0;        SB_ = 1;        delay(time);        SA = 1;        SA_ = 1;        SB = 0;        SB_ = 1;        delay(time);        SA = 1;        SA_ = 0;        SB = 0;        SB_ = 1;        delay(time);        SA = 1;        SA_ = 10;        SB = 1;        SB_ = 1;        delay(time);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><font color="red">值得注意的是，如果你的步进电机的相序出错的话就会造成左右都懂，这样就要检查一下你的相序是不是对的</font>。</li><li>温馨提示：步进电机运行久了会很烫，不要用手直接触碰</li><li>对步进电机的调速，可以通过每步之间的延时来达到，延时越长，运动越慢。</li></ul><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>  示效果的时间到了。从动图中可以看到转的很慢，但是实际上转的比这个快一些，主要是动图丢帧比较严重.</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-stepper_motor/display.gif" alt="运行结果" title="运行结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 步进电机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机PWM驱动LED</title>
      <link href="/2019/d7033870.html"/>
      <url>/2019/d7033870.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>PWM控制广泛的运用在单片机领域，LED灯光亮度驱动，电机速度驱动等都会用到，51单片机没有继承PWM模块，所以需要使用定时器进行模拟，本文就讲述如何使用定时器来模拟PWM功能实现对LED的亮度的控制。以前发帖在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100307-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  本文中使用的是定时器0，通过配置定时器0为定时模式就可以了，然后在程序中打开定时器，定时时间间隔设置的小一点，设置的太大会造成不流畅的情况。</p><p>  我在程序中设置的是0.01ms，周期为100，通过变量duty就可以改变占空比。如果要控制舵机运动的话，可以将定时时间设置成0.2ms，这样100次就是20ms，因为舵机控制需要周期为20ms的方波驱动，然后通过设置占空比就可以控制舵机运动了。</p><h1 id="51单片机PWM原理"><a href="#51单片机PWM原理" class="headerlink" title="51单片机PWM原理"></a>51单片机PWM原理</h1><p>  因为51单片机没有硬件PWM，所以采用定时器0来控制，控制原理就是通过周期性的输出高低电平来控制输出高电平和低电平的时间，周期一般要小于30ms，因为人的眼睛的刷新频率就差不多是30ms，如果大于30ms就会出现闪烁的效果，达不到理想的效果。</p><p>  使用PWM还需要知道一个知识点就是占空比，占空比就是在一个周期中输出的高电平占整个周期的比值。</p><p>  这个需要看驱动的LED是阴极驱动还是阳极驱动，如果是阴极驱动，占空比越大，LED亮度越低反之越高，阳极控制的相反。</p><h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>  接下来就是写程序了。</p><pre class="line-numbers language-C"><code class="language-C">#include <reg52.h>#define uchar unsigned char#define uint  unsigned intsbit pwm = P3^7;                //定义PWM引脚为P3.7uchar duty = 100;void timer0_Init(void);void Set_Duty(void);void delay_ms(uint ms);int main(){        int i;        timer0_Init();        while(1)        {                for(i=100;i>0;i-=1)                {                        duty = i;                        delay_ms(1);                }                        for(i=0;i<10;i+=1)                {                        duty = i;                        delay_ms(1);                }        }}//延时函数void delay_ms(int ms){        uint i;        for(;ms>0;ms--)                for(i=0;i<110;i++);}//定时器0初始化void timer0_Init(void){        TMOD|=0X01;                        //选择为定时器0模式，工作方式1，仅用TR0打开启动。        TH0=(65536-20)/256;        //给定时器赋初值，50us        TL0=(65536-20)%256;                ET0=1;                                //允许定时器中断0        EA=1;                                //打开总中断        TR0=1;                                //打开定时器                        }//使用定时0模拟PWMvoid timer0() interrupt 1{                static uint pwm_count = 0;        TH0=(65536-10)/256;        //给定时器赋初值，50us        TL0=(65536-10)%256;                pwm_count ++;                if(pwm_count >= 100)        {                pwm_count = 0;        }else if(pwm_count <= duty)        {                pwm = 0;        }else        {                pwm = 1;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序说明：duty变量就是占空比的控制变量，通过调节该值可以控制占空比大小，该值最大为100。</p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>  如下图，可以看到LED呈现明暗的变化</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-PWM//display1.gif" alt="运行结果" title="运行结果"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-PWM//display1.gif" alt="运行结果" title="运行结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> PWM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机驱动LCD1602</title>
      <link href="/2019/b115335.html"/>
      <url>/2019/b115335.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>单片机中用到数据显示的时候使用LCD1602的时候还是挺多的，本文讲解了对LCD1602的使用操作。以前发帖在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100298-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>  首先查看原理图。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/LCD1602.png" alt="原理图" title="原理图"></p><p>  从上面的原理图中可以看出，LCD1602是使用P0操作的，还有一个电位器可以用来调节显示亮度。</p><p>  三个读/写时序操作引脚需要自己根据自己的实际情况连接，我是连接在下面三个引脚上的</p><ul><li>rs ====&gt; P2^6</li><li>rw====&gt; P2^5</li><li>e  ====&gt; P2^7</li></ul><p>  LCD1602在开发板上的显示如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/LCD1602_conect.png" alt="LCD1602" title="LCD1602"></p><h1 id="LCD1602时序"><a href="#LCD1602时序" class="headerlink" title="LCD1602时序"></a>LCD1602时序</h1><h2 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h2><p>  写时序如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/Write_time_seq.png" alt="写时序图" title="写时序图"></p><p>  首先要对寄存器的选择和读、写操作选择进行配置。<br>  RS是寄存器选择，rs = 1对数据进行操作；rs = 0对指令进行操作。<br>  接着对读写操作选择进行配置，rw = 0 写操作。<br>  打开使能端，输入使能信号 e = 1。<br>  数据总线，对DB0~DB7（就是P0）赋值，进行数据的传输。</p><h2 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h2><p>  读时序如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/Read_time_seq.png" alt="读时序图" title="读时序图"></p><p>  理解方式与上面写时序是一样的。</p><h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>  知道了原理图，接下来就是写程序了。</p><pre class="line-numbers language-C"><code class="language-C"> #include<reg52.h>#define uchar unsigned char#define uint unsigned intsbit rs=P2^6;sbit rw=P2^5;sbit e=P2^7;uchar xs1[]=" hello,welcome you! ";uchar xs2[]="    I am happy!     ";uchar table[]={0x01,0x03,0x07,0x08,0x1f,0x3f,0x7f,0xff};void yan(uint ms){     uint w;         for(;ms>0;ms--)            for(w=110;w>0;w--);}void xzl(uchar com){     e=0;     rs=0;         rw=0;         P0=com;         yan(1);         e=1;         yan(2);         e=0;}void xsj(uchar dat){         e=0;     rs=1;         rw=0;         P0=dat;         yan(1);         e=1;         yan(2);         e=0;}void init(){         xzl(0x38);         xzl(0x08);         xzl(0x01);         xzl(0x06);         xzl(0x0c);} void main(){     uchar i;     init();         xzl(0x80+0x16);         for(i=0;i<16;i++)         {             xsj(xs1[i]);                //显示第一行数据                 yan(30);         }         xzl(0x80+0x40+0x16);         for(i=0;i<16;i++)         {             xsj(xs2[i]);                //显示第二行数据                 yan(30);         }          while(1)          {                 for(i=0;i<40;i++)                 {                      xzl(0x1c);                //右移命令                          yan(300);                 }                    }                  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>  写好了程序之后就是验证我们的实验结果了，由于使用了右移命令，所以文字连续向右移动，感兴趣的小伙伴可以试一下，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/Display1.gif" alt="运行结果" title="运行结果"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/display2.gif" alt="运行结果" title="运行结果"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p><a href="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/LCD1602液晶完整中文资料.pdf" target="_blank" rel="noopener">点我下载LCD1602液晶完整中文资料</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> LCD1602 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机DS18B20获取温度</title>
      <link href="/2019/959f1fc5.html"/>
      <url>/2019/959f1fc5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>DS18B20是一个高精度的温度获取芯片，该芯片是单总线的，时序图也比较简单，最初发帖是在电子芯巴克。原帖子链接：<a href="https://bbs.icxbk.com/thread-100156-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>  首先查看原理图，从下面的图中可以看出DS18B20是连接在P3.7引脚上面的。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS_18B20_temperature/DS18B20.png" alt="DS18B20接线图" title="DS18B20接线图"></p><p>  下面是数码管的原理图，因为温度数据要通过数码管显示出来。数码管的教程在前面已经写过了，在这里不再做介绍：<a href="http://hehung.top/archives/9ea6.html">点我查看数码管操作</a></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources@master/51-DS_18B20_temperature/Tube.png" alt="数码管原理图" title="数码管原理图"></p><p>  从上面的原理图中可以看到，DS18B20的引脚是P3.7<br>  数码管接法：</p><ul><li>J12 —  P0</li><li>A — P1.0</li><li>B — P1.1 </li><li>C — P1.2</li></ul><p>  其中A,B,C是数码管的位选端口，在上一篇帖子里我已经说明了</p><h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>  知道了原理图，接下来就是写程序了。<br>  本来像这种函数比较多的程序一般都是要写在不同的文件里面的，使用模块化编程的。但是我为了简单，就写在了一个文件里。<br>  我觉得代码还是写的比较规范的，注释也清楚，有需要的小伙伴直接拿去改下端口就可以用。</p><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>#define uchar unsigned char#define uint unsigned int#define SMG P0                //定义数码管的段选端口//下述的A,B,C的信号进过译码器解码后可以控制8个数码管的显示sbit LA=P1^0;                sbit LB=P1^1;sbit LC=P1^2;sbit dq=P3^7;        //DS18B20的引脚//下面的数组可以显示0-Fuchar code number[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,                                        0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};//函数声明void delay(int ms);                                                //延时函数void change(int what);                                        //位选函数void ds18b20_init();                                        //DS18B20初始化函数void ds18b20_write_data(uchar dat);                //DS18B20写命令函数uchar ds18b20_read_data();                                //DS18B20读数据函数void ds18b20_read_temp(int *temp,int *xiao);        //DS18B20读温度函数void display(int temp, int xiao);                //数码管显示函数//主函数void main(){        int temp,xiao;                //定义温度的整数和小数变量        ds18b20_init();                //初始化        while(1)        {                ds18b20_read_temp(&temp, &xiao);                display(temp, xiao);        }}//延时函数(短延时)void delay(int ms){        while(ms--);}//该函数可以选择某一个数码管显示void change(int what){        switch(what)        {                case 1:LC=0;LB=0;LA=0;break;                case 2:LC=0;LB=0;LA=1;break;                case 3:LC=0;LB=1;LA=0;break;                case 4:LC=0;LB=1;LA=1;break;                case 5:LC=1;LB=0;LA=0;break;                case 6:LC=1;LB=0;LA=1;break;                case 7:LC=1;LB=1;LA=0;break;                case 8:LC=1;LB=1;LA=1;break;                        }}//初始化函数void ds18b20_init(){            dq=1;         delay(5);         dq=0;         delay(400);         dq=1;         delay(300);}void ds18b20_write_data(uchar dat){     uchar i;         for(i=0;i<8;i++)         {             dq=0;                 dq=dat&0x01;                 delay(2);                 dq=1;                 dat>>=1;         }          delay(4);    }uchar ds18b20_read_data(){          uchar i,v;          for(i=0;i<8;i++)          {              dq=0;                  v>>=1;                  dq=1;                  if(dq)                     v|=0x80;                  delay(4);          }          return v;}void ds18b20_read_temp(int *temp,int *xiao){                   uchar a,b;     ds18b20_init();         ds18b20_write_data(0xcc);         ds18b20_write_data(0x44);         delay(200);         ds18b20_init();         ds18b20_write_data(0xcc);         ds18b20_write_data(0xbe);                //读温度         a=ds18b20_read_data();          //读出温度低位         b=ds18b20_read_data();           //读出温度高位         b<<=4;         b+=(a&0xf0)>>4;         *temp=b;                                //温度整数部分         *xiao=a&0x0f;                                 *xiao=*xiao/1.6;                //温度小数部分}void display(int temp, int xiao){        change(1);        SMG=number[temp/10];        delay(100);        SMG = 0;        delay(30);         //消除暗影        change(2);        SMG=number[temp%10];        delay(100);        SMG = 0;        delay(30);         //消除暗影        change(3);        SMG=~0x7f;        delay(100);        SMG = 0;        delay(30);         //消除暗影        change(4);        SMG=number[xiao];        delay(100);        SMG = 0;        delay(30);         //消除暗影}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>  写好了程序之后就是验证我们的实验结果了，首先要知道DS18B20长得什么样的，在单片机的位置，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS_18B20_temperature/DS18B20_in_board.png" alt="DS18B20在单片机中的位置" title="DS18B20在单片机中的位置"></p><p>  可以想办法给DS18B20加热，温度数值就会增加。<br>  如下图，我是用手给它捏住，它的温度就会上升。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS_18B20_temperature/Display_dynamic1.gif" alt="DS18B20在单片机中的位置" title="DS18B20在单片机中的位置"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-DS_18B20_temperature/Display_dynamic2.gif" alt="DS18B20在单片机中的位置" title="DS18B20在单片机中的位置"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> DS18B20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机数码管显示</title>
      <link href="/2019/aa7cc8bc.html"/>
      <url>/2019/aa7cc8bc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一次做了一个流水灯，现在还是从基础做起，做一个可以滚动显示的数码管。废话不多说，首先展示一下滚动显示的效果，原帖子链接：<a href="https://bbs.icxbk.com/thread-100110-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>  程序实现了动态数码管的显示，滚动显示1-F，如下图所示，<br>  由于使用手机自带的gif拍摄的图片，只能拍摄很短的gif图片，所以就多放了几张。<br>  我是向左滚动的滚动的时间大约500ms左右，随便写的，并不准确，会循环连续的滚动，图中不太容易看出效果。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-Digital_tube/2.gif" alt="运行效果" title="运行效果"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-Digital_tube/3.gif" alt="运行效果" title="运行效果"></p><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>  在单片机开发中，能看懂原理图是非常重要的，因为单片机的开发一般都是对外设的驱动，知道电路如何连接，才能很好的控制。</p><p>  首先打开原理图，可以看到原理图中所有的数码管都是接在J16上的，而J16又是通过译码器连接到J6，单片机上的A,B,C引脚。所以通过A,B,C可以控制数码管得位选。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-Digital_tube/4.png" alt="原理图" title="原理图"></p><p>  同时，原理图还说明了数码管是共阴的，也就是阴极都是连在一起的，如果要控制数码管亮的话，就需要在阳极给高电位，也就是给1。</p><p>  这里说一下我的数码管的链接引脚：<br>A ===  P1.0<br>B ===  P1.1<br>C ===  P1.2<br>然后就是J12口是控制段选的，J12通过P0口控制。</p><h1 id="数码管控制原理"><a href="#数码管控制原理" class="headerlink" title="数码管控制原理"></a>数码管控制原理</h1><h2 id="位选和段选"><a href="#位选和段选" class="headerlink" title="位选和段选"></a>位选和段选</h2><p>  因为单片机的控制引脚有限，一个数码管在操作的时候会使用8个IO口进行控制，为了减少IO口的开销，在电路设计上就是用了段选和位选来用相同的IO口数对多个数码管进行操作。</p><p>  对多个数码管操作的时候有段选和位选：位选就是选择某一个数码管，对其进行操作；段选就是选择数码管的某一段操作，一般数码管有7段，如果数码管有小数点的话就会有8段，就可以通过8个IO口对数码管的每一段的亮灭进行控制。</p><h2 id="位选控制"><a href="#位选控制" class="headerlink" title="位选控制"></a>位选控制</h2><p>  位选是如何工作的呢？这里有8个数码管，但是只有三个控制引脚，因为有译码器，所以给这三个引脚不同的值就会控制打开不同的数码管，比如：</p><ul><li>A=0，B=0，C=0就是控制第1个数码管</li><li>A=0，B=0，C=1就是控制第2个数码管</li><li>…</li></ul><h2 id="段选控制"><a href="#段选控制" class="headerlink" title="段选控制"></a>段选控制</h2><p>  段选使用8个IO口进行控制。如原理图中所示的J12，因为数码管是共阴的，所以控制IO输出为1就会使相应的一段变亮。</p><p>  原理图中对数码管的的每一段都有标注a,b,c,d,e,f,g,dp。如果将J12连接到P0，也就是P0.7控制a，P0.6控制b … P0.0控制dp。</p><p>  所以，如果要控制数码管显示数字，应该给IO口P0赋值下列数字：</p><ul><li>0 – 0x3f </li><li>1 – 0x06 </li><li>2 – 0x5b</li><li>3 – 0x4f</li><li>4 – 0x66</li><li>5 – 0x6d</li><li>6 – 0x7d</li><li>7 – 0x07</li><li>8 – 0x7f</li><li>9 – 0x6f</li><li>A – 0x77</li><li>B – 0x7c</li><li>C – 0x39</li><li>D – 0x5e</li><li>E – 0x79</li><li>F – 0x71 </li></ul><h1 id="程序编辑"><a href="#程序编辑" class="headerlink" title="程序编辑"></a>程序编辑</h1><p>  知道了原理图的连接和控制原理，现在就可以对数码管的显示进行程序程序的编写了。</p><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>#define uchar unsigned char#define uint unsigned int#define SMG P0                //定义数码管的段选端口//下述的A,B,C的信号进过译码器解码后可以控制8个数码管的显示sbit LA=P1^0;                sbit LB=P1^1;sbit LC=P1^2;//下面的数组可以显示0-Fuchar code number[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,                                        0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};//函数声明void delay(int ms);void change(int what);//延时函数(短延时)void delay(int ms){        for(;ms>0;ms--);}//该函数可以选择某一个数码管显示void change(int what){        switch(what)        {                case 1:LC=0;LB=0;LA=0;break;                case 2:LC=0;LB=0;LA=1;break;                case 3:LC=0;LB=1;LA=0;break;                case 4:LC=0;LB=1;LA=1;break;                case 5:LC=1;LB=0;LA=0;break;                case 6:LC=1;LB=0;LA=1;break;                case 7:LC=1;LB=1;LA=0;break;                case 8:LC=1;LB=1;LA=1;break;                        }}int main(){        uchar i;        uchar j=0;        uint time=50;        while(1)        {                for(;time>0;time--)                {                        for(i=1;i<=8;i++)                        {                                change(i);                                SMG = number[(j+i)%16];                //使之可以滚动显示的处理                                        delay(100);                                SMG = 0;                                delay(50);         //消除暗影                        }                                }                time = 50;                j++;                if(j>17)                        j = 0;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述程序就是实现了对8个数码管显示0-F的滚动显示程序。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 数码管 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机开发环境搭建+流水灯</title>
      <link href="/2019/d646b561.html"/>
      <url>/2019/d646b561.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前在论坛上获取了一块51单片机的板子，集成了ARM+51单片机两种芯片，包括很多的外设和资料。在使用过程中写了部分教程，如果要看原贴：<a href="https://bbs.icxbk.com/thread-100061-1-1.html" target="_blank" rel="noopener">点我跳转</a></p></blockquote><h1 id="创建51单片机工程"><a href="#创建51单片机工程" class="headerlink" title="创建51单片机工程"></a>创建51单片机工程</h1><p>  编译器选用的是keil 5，keil5相对于keil4更加的好用，同时支持stm32编程，但是keil5原始的下载安装包中是不带有51单片机的pack包的，所以需要自己在官网上下载一个C51的pack包，安装之后就可以正常给51单片机编程了。<br>下面开始讲解工程创建。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>  如下图所示，选择Project =&gt; New jVision Project…</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/create_project1.png" alt="新建项目" title="新建项目"></p><h2 id="输入工程名字"><a href="#输入工程名字" class="headerlink" title="输入工程名字"></a>输入工程名字</h2><p>  选择一个路径保存你新建的工程，然后输入工程的名字，如下图所示：</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA2.png" alt="选择项目路径与名字" title="选择项目路径与名字"></p><h2 id="单片机型号选择"><a href="#单片机型号选择" class="headerlink" title="单片机型号选择"></a>单片机型号选择</h2><p>  选择单片机的型号，如下图，选择AT89C52，如果用的是STC89系列的51单片机，也需要选择这个，因为编译器里面没有STC89C51的选项，并且这里的操作方式和使用MDK4的时候是不一样的。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E9%80%89%E6%8B%A9%E5%8D%95%E7%89%87%E6%9C%BA%E5%9E%8B%E5%8F%B7.png" alt="选择单片机型号" title="选择单片机型号"></p><h2 id="新建一个空白文件"><a href="#新建一个空白文件" class="headerlink" title="新建一个空白文件"></a>新建一个空白文件</h2><p>  点击下图所示的图标，新建一个空白编辑界面，这个就是要用到的.c文件。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BD%E6%96%87%E4%BB%B6.png" alt="新建一个空白文件" title="新建一个空白文件"></p><h2 id="另存为-c文件"><a href="#另存为-c文件" class="headerlink" title="另存为.c文件"></a>另存为.c文件</h2><p>  点击另存为，给新建的空杯文件输入一个名字，注意：名字后面的.c不要漏写。等会写的代码就会存放在这个文件里面，一般与工程保存在同一个文件目录下。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E7%BB%99%E6%96%87%E4%BB%B6%E6%94%B9%E5%90%8D.png" alt="另存为空白文件" title="另存为空白文件"></p><h2 id="将-c文件加入工程"><a href="#将-c文件加入工程" class="headerlink" title="将.c文件加入工程"></a>将.c文件加入工程</h2><p>  新建的空白文件还没有加入到工程中，所以需要将该文件加入到工程中，如下图所示，双击Source Group，在弹出的选择框中选择新建的.c文件</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E5%B0%86%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%8A%A0%E5%85%A5%E5%B7%A5%E7%A8%8B.png" alt="将新建文件加入工程" title="将新建文件加入工程"></p><h1 id="代码编辑与下载"><a href="#代码编辑与下载" class="headerlink" title="代码编辑与下载"></a>代码编辑与下载</h1><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>  文件加入工程之后就是编写代码了。</p><p>  因为给单片机编程是要根据你的单片机电路的实际布局来编写的，因为我的单片机的8路LED都是接在P0口上的，所以在程序中用P0来控制LED的亮灭。</p><pre class="line-numbers language-C"><code class="language-C">#include <reg52.h>#define uchar unsigned char#define uint unsigned int//写一个延时函数void delay(uint ms){    uchar i;    for(;ms>0;ms--)        for(i=110;i>0;i--);}int main(){    uchar kk = 0x01;    P0 = kk;            while(1)    {        kk <<= 1;        //左移，如果右移可以改为kk >>= 1;        if(kk == 0)        {            kk = 0x01;        }        P0 = kk;        delay(1000);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  程序编写完成之后就是编译了，顺利编译通过就表示没有语法错误了，现在开始下一步，生成hex文件。</p><h2 id="hex文件生成"><a href="#hex文件生成" class="headerlink" title="hex文件生成"></a>hex文件生成</h2><p>  如下图所示。选择该图标，在弹出的对话框中选择Output，将创建HEX文件的对话框前面打上对勾，这样再次编译工程之后就可以在指定目录下生成一个.hex文件。这是一种16进制的文件，直接下载到单片机中运行即可。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E9%80%89%E6%8B%A9%E7%94%9F%E6%88%90hex%E6%96%87%E4%BB%B6.png" alt="选择生成hex文件" title="选择生成hex文件"></p><h2 id="下载软件到单片机"><a href="#下载软件到单片机" class="headerlink" title="下载软件到单片机"></a>下载软件到单片机</h2><p>  打开stc-isp-15xx-v6.86F.exe软件，选择相应的单片机型号，我这里得单片机是89C516，这块单片机我以前都没见过，试了很多种型号的都下载不了，最后在89c58里面才找到这个型号。</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6.png" alt="使用工具下载软件" title="使用工具下载软件"></p><p>如果使用同样型号的单片机的小伙伴可以看下图：</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E5%8D%95%E7%89%87%E6%9C%BA%E5%9E%8B%E5%8F%B7%E9%80%89%E6%8B%A9.png" alt="单片机型号选择" title="单片机型号选择"></p><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p>  将程序下载到单片机之后就可以查看运行效果了，如下图所示：</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.gif" alt="运行效果" title="运行效果"></p><p>  附上我的接线图</p><p><img src="https://hehung-blog-respurces.oss-cn-beijing.aliyuncs.com/51_project_create_and_water_light/%E6%8F%92%E7%BA%BF%E8%BF%9E%E6%8E%A5.jpg" alt="插线连接" title="插线连接"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取5天的天气</title>
      <link href="/2019/51fc7eef.html"/>
      <url>/2019/51fc7eef.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前在学习python的时候用python做了一个可以获取5天天气的一个程序，分享在了CSDN的博客上，现在转载到我的个人博客，原链接请点击：<a href="https://blog.csdn.net/hehung/article/details/78229098" target="_blank" rel="noopener" title="点我跳转">点我跳转</a></p></blockquote><h1 id="获取天气网址介绍"><a href="#获取天气网址介绍" class="headerlink" title="获取天气网址介绍"></a>获取天气网址介绍</h1><p>今天学了学python的json操作，然后就想弄个获取天气的程序试试。</p><p>但是要就行天气获取，就要找到天气的json接口文件。在网上搜集了一圈，发现下面的网址可以提供5天的天气查询的json，很实用。</p><h2 id="获取天气网址"><a href="#获取天气网址" class="headerlink" title="获取天气网址"></a>获取天气网址</h2><p>网址：?<a href="http://wthrcdn.etouch.cn/weather_mini?city=北京" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?city=北京</a></p><p>注意：这个网址的后面的地名可以自己更改，如<a href="http://wthrcdn.etouch.cn/weather_mini?city=上海" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?city=上海</a></p><p>对了，如果打开的页面是乱码，那是因为问个的显示编码方式不对，在网页单击鼠标右键，选择编码 ?，选择?Unicode（UTF-8），用的浏览器不一样，操作方式应该不一样，只要将网站的显示页面的编码方式改成utf-8就行了</p><p>如下图，查找的深圳的天气，直接将后面的北京改成深圳就ok了<br><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/python%E8%8E%B7%E5%8F%965%E5%A4%A9%E7%9A%84%E5%A4%A9%E6%B0%94/%E6%9F%A5%E8%AF%A2%E5%A4%A9%E6%B0%94.png" alt="天气网址" title="天气网址"></p><p>这样子看这个文档很不方便，眼睛都看花了，下面我们就用python程序的pprint模块来美化一些这个字典</p><h1 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h1><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> json<span class="token punctuation">,</span> requests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两个模块是必须的:<br>1、json可以用来将网页的json解析成python能识别的字典表示。<br>2、requests模块用来获取下载网站，即json的网站页面，用来方便处理。</p><h2 id="导入链接，获取页面"><a href="#导入链接，获取页面" class="headerlink" title="导入链接，获取页面"></a>导入链接，获取页面</h2><p>获取天气查询时候返回的json文本，主要就是对这个文本信息进行处理分析。</p><pre class="line-numbers language-python"><code class="language-python">weatherJsonUrl <span class="token operator">=</span> <span class="token string">"http://wthrcdn.etouch.cn/weather_mini?city=北京"</span>  <span class="token comment" spellcheck="true">#将链接定义为一个字符串</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>weatherJsonUrl<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">#获取并下载页面，其内容会保存在respons.text成员变量里面</span>response<span class="token punctuation">.</span>raise_for_status<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#这句代码的意思如果请求失败的话就会抛出异常，请求正常就上面也不会做</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="解析json文件"><a href="#解析json文件" class="headerlink" title="解析json文件"></a>解析json文件</h2><p>需要解析的变量就是上一步的成员变量respons.text。<br>如下所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#将json文件格式导入成python的格式</span>weatherData <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用漂亮打印打印转换后的python字典-weatherData变量"><a href="#使用漂亮打印打印转换后的python字典-weatherData变量" class="headerlink" title="使用漂亮打印打印转换后的python字典(weatherData变量)"></a>使用漂亮打印打印转换后的python字典(weatherData变量)</h2><p>最后我们需要使用print查看一下数据，但是使用原来的语言自带的print不是很方便，看着很难识别字符，所以使用一个模块pprint。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pprint               <span class="token comment" spellcheck="true">#导入pprint模块</span>pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>weatherData<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#漂亮打印出天气字典</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行结果如下图所示：（我只截取了一部分图形，太长了）:<br><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/python%E8%8E%B7%E5%8F%965%E5%A4%A9%E7%9A%84%E5%A4%A9%E6%B0%94/%E8%8E%B7%E5%8F%96%E7%9A%84%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE.png" alt="获取的json数据" title="获取的json数据"></p><p>从上面的图形可以看出‘data’是字典的第一个键，其值也是一个字典，这个字典中键’forecast’才是表示天气信息的。</p><p>‘date’:表示日期 ……等 。这些应该都看得懂，就不浪费时间解释了……</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>接下来就是对这个字典（weatherData）的数据进行处理<br>就是平时处理字典与列表的方式即可。</p><p>举例：</p><p>获取今天的天气：</p><pre class="line-numbers language-python"><code class="language-python">weatherData<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'forecast'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#输出>> '晴'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取今天的温度：</p><pre class="line-numbers language-python"><code class="language-python">weatherData<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'wendu'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#输出>> '16'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原理还是很简单的，用到的只是也不是很多，就是字典数据的处理，json的获取等。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>下面分享获取天气的源码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!python3</span><span class="token comment" spellcheck="true">#coding:utf-8</span><span class="token keyword">import</span> json<span class="token punctuation">,</span> sys<span class="token punctuation">,</span> requests<span class="token comment" spellcheck="true">#输入地点</span>weatherPlace <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入天气地点："</span><span class="token punctuation">)</span><span class="token keyword">if</span> weatherPlace <span class="token operator">==</span> <span class="token string">'E'</span> <span class="token operator">or</span> weatherPlace <span class="token operator">==</span> <span class="token string">'e'</span><span class="token punctuation">:</span>    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#关闭程序</span><span class="token comment" spellcheck="true">#下载天气JSON</span>weatherJsonUrl <span class="token operator">=</span> <span class="token string">"http://wthrcdn.etouch.cn/weather_mini?city=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>weatherPlace<span class="token punctuation">)</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>weatherJsonUrl<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    response<span class="token punctuation">.</span>raise_for_status<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"网址请求出错"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将json文件格式导入成python的格式</span>weatherData <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>response<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#以好看的形式打印字典与列表表格</span><span class="token comment" spellcheck="true">#import pprint</span><span class="token comment" spellcheck="true">#pprint.pprint(weatherData)</span>w <span class="token operator">=</span> weatherData<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"地点：%s"</span> <span class="token operator">%</span> w<span class="token punctuation">[</span><span class="token string">'city'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#日期</span>date_a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#最高温与最低温</span>highTemp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>lowTemp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#天气</span>weather <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#进行五天的天气遍历</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>w<span class="token punctuation">[</span><span class="token string">'forecast'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    date_a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">[</span><span class="token string">'forecast'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'date'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    highTemp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">[</span><span class="token string">'forecast'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'high'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    lowTemp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">[</span><span class="token string">'forecast'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'low'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    weather<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">[</span><span class="token string">'forecast'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#输出</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"日期："</span> <span class="token operator">+</span> date_a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t温度：最"</span> <span class="token operator">+</span> lowTemp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'℃~最'</span> <span class="token operator">+</span> highTemp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'℃'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t天气："</span> <span class="token operator">+</span> weather<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n今日着装："</span> <span class="token operator">+</span> w<span class="token punctuation">[</span><span class="token string">'ganmao'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前温度："</span> <span class="token operator">+</span> w<span class="token punctuation">[</span><span class="token string">'wendu'</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"℃"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>上述代码在运行的时候要输入 &gt;&gt;  地名 &lt;&lt;  ，如下图：<br><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/python%E8%8E%B7%E5%8F%965%E5%A4%A9%E7%9A%84%E5%A4%A9%E6%B0%94/%E8%BE%93%E5%85%A5%E5%9C%B0%E7%82%B9.png" alt="输入地点" title="输入地点"></p><p>运行结果如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/python%E8%8E%B7%E5%8F%965%E5%A4%A9%E7%9A%84%E5%A4%A9%E6%B0%94/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果" title="运行结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> requests </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机的音乐盒(c语言)</title>
      <link href="/2019/be57a96f.html"/>
      <url>/2019/be57a96f.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　该文章是我在2016年的时候发布在电子发烧友论坛上面的，但是还是在校大学生，没有个人博客，现在搭建了一个个人博客，所以就把文章转到了个人博客上了。该文章在电子发烧友上的链接：<a href="http://bbs.elecfans.com/jishu_1102723_1_1.html" target="_blank" rel="noopener" title="[经验] 51单片机的音乐盒(c语言)">[经验] 51单片机的音乐盒(c语言)</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>　　以前也用各种单片机做个一些东西，但都没想过发帖，最近比较关注这个论坛，所以也来发过帖子玩玩。</p><p>　　到期末了。这学期学了单片机这门课，用的是汇编语言，但是说实话，学了一个学期的汇编语言，对汇编语言还是不太会用。期末了要单片机的实验考试，老师要求可以做一个音乐盒或者汉字点阵就免考，虽然考试也很简单，但是我还是决定做一个实物，显得”高大上”,本人大一的时候就学会了C语言对单片机的编程，这次课程设计当然也要用C语言来完成了。</p><p>　　最开始本来是想做一个显示汉字的点阵的，但是网上一搜电路图，太复杂了，如果要显示汉字就必须要使用4块8*8的点阵，电路图复杂的可怕，如果要手焊的话，估计每个两三天完成不了，本着简单快速的原则，我就做一个音乐盒算了。</p><p>　　既然想好了做音乐盒，接下来就是准备元器件了，要用到的元器件有：1602液晶，52单片机，,按键，各种电容，电阻，三极管，无源蜂鸣器等，是不是废话有点多了，哈哈…</p><h1 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h1><p>　　音乐盒所要用到的原理图都是我从网上搜的，所以与我所做的实物的线路连接还是有一些区别的，还是贴一下图吧。</p><h2 id="52单片机最小系统板电路图"><a href="#52单片机最小系统板电路图" class="headerlink" title="52单片机最小系统板电路图　"></a>52单片机最小系统板电路图　</h2><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/51%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%94%B5%E8%B7%AF.jpg" alt="51单片机最小电路" title="51单片机最小电路"></p><h2 id="1602液晶电路图"><a href="#1602液晶电路图" class="headerlink" title="1602液晶电路图"></a>1602液晶电路图</h2><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/LCD1602%E6%B6%B2%E6%99%B6%E5%B1%8F%E7%94%B5%E8%B7%AF.jpg" alt="LCD1602液晶屏电路" title="LCD1602液晶屏电路"></p><h2 id="蜂鸣器驱动电路图"><a href="#蜂鸣器驱动电路图" class="headerlink" title="蜂鸣器驱动电路图"></a>蜂鸣器驱动电路图</h2><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/%E8%9C%82%E9%B8%A3%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF.jpg" alt="蜂鸣器驱动电路" title="蜂鸣器驱动电路"></p><h2 id="按键电路图"><a href="#按键电路图" class="headerlink" title="按键电路图"></a>按键电路图</h2><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/%E6%8C%89%E9%94%AE%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1.jpg" alt="按键电路设计" title="按键电路设计"></p><p>　　 这里有两种案件的连接方式，我采用的是第一种，这样写程序的时候，当按键按下时，相应的IO口就会变成低电平，而第二种相应的IO口会变成高电平。</p><h1 id="电路焊接"><a href="#电路焊接" class="headerlink" title="电路焊接"></a>电路焊接</h1><p>　　接下来就开始焊接了，但是我是在吧实物做好了之后才想起来要发帖的，所以焊接的过程就yy一下就行了….其实焊接的过程很简单，花了我一个下午加晚上的时间，不要问我为什么花费这么久，看图。</p><p>先上一张正面图</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/%E5%AE%8C%E6%88%90%E4%BD%9C%E5%93%81%E6%AD%A3%E9%9D%A2.jpg" alt="完成作品正面" title="完成作品正面"></p><p>背面图</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/%E5%AE%8C%E6%88%90%E4%BD%9C%E5%93%81%E8%83%8C%E9%9D%A2%E5%9B%BE.jpg" alt="完成作品背面图" title="完成作品背面图"></p><h1 id="引脚连接"><a href="#引脚连接" class="headerlink" title="引脚连接"></a>引脚连接</h1><p>　　背面的电路图看着有点乱，但是仔细焊接的话，还是不复杂的。<br>　　你们可能会疑惑我为什么会加一排LED灯，那是我无聊加上的，用来配合音乐播放时的节拍，很low…….haha<br>下面说一下我的实物图的接线<br>＝＝》蜂鸣器——–&gt;P1^3<br>＝＝》暂停按键——&gt;P3^7，按下暂停后会在右上角显示pause，表示已经暂停了<br>＝＝》下一首按键—-&gt;P3^6<br>＝＝》上一首按键—-&gt;P3^5<br>　　这样就完成了，其实做的这个还是很low的，实在无聊就发个帖子玩玩。</p><h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p>　　说一下缺陷：这个蜂鸣器有个毛病，就是声音大了就很有很多杂音，最开始的时候本来没串接电阻，声音是很大，只不过杂音太大了，基本上听不到音乐，之后接了一个大一点的电阻，音乐是有了，但是声音又太小了，没办法，我就串接了一个电位器，可以用来调节音量的大小，但是声音大了还是会有杂音。所以最好还是有个喇叭。</p><p>　　在附几张图。我用的是1602，不能显示中文（能显示，只不过没花时间去弄，期末了，要复习），如果想方便显示中文的话害的要一个12864液晶，显示中文很方便。</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/%E6%88%90%E5%93%81%E5%B1%95%E7%A4%BA%EF%BC%91.jpg" alt="成品展示１" title="成品展示１"></p><p>来张动态图</p><p><img src="https://cdn.jsdelivr.net/gh/hehung/51_music_player/img/%E6%88%90%E5%93%81%E5%B1%95%E7%A4%BA%EF%BC%92.gif" alt="成品展示２" title="成品展示２"></p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p>　　这个程序的歌词代码也是我从网上搜集来的，只不过网上的代码都没怎么集合，很零散，而且每个代码的写法都不同，经过我几个小时的整合，我把一些代码都集合了起来，目前放了5首歌在里面，包含了，暂停，上一曲和下一曲的功能。功能都能够实现。</p><p>代码我已经整合到了，如果感兴趣可以下载：<br><a href="https://cdn.jsdelivr.net/gh/hehung/51_music_player/音乐播放器.7z" target="_blank" rel="noopener" title="直接下载">直接下载</a></p><p>去github：<a href="https://github.com/hehung/51_music_player" target="_blank" rel="noopener" title="点此处去github">点击此处去github</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 51单片机 </tag>
            
            <tag> 电路设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于stm32的心率监控装置</title>
      <link href="/2019/e5a76ffe.html"/>
      <url>/2019/e5a76ffe.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　该文主要讲述了以前用STM32实现的一个心率传感装置的制作过程和最终实现的效果，这是我在大四毕业的时候帮别人做的一个毕业设计的小作品，最初的文章是发表在电子发烧友上面的，现转载到我的个人博客来。<br>原链接请点击此处：<a href="http://bbs.elecfans.com/forum.php?mod=viewthread&amp;tid=1600343&amp;page=1#pid7932932" target="_blank" rel="noopener" title="点我跳转">点我跳转</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>　　最近做了一个机遇STM32的心率监测装置，使用了一块oled屏幕进行检测到的心率的波形的显示。<br>心率监测传感器使用的传感器是pulse sensor，是一款比较便宜的传感器。显示屏采用的是128X64的oled显示器。</p><p>　　首先放上成品图，不然你们是没有兴趣看的。^_^<br><img src="https://cdn.jsdelivr.net/gh/hehung/stm32-heart-rate-monitoring/img/Heart_rate_oscillogram.gif" alt="心率动态显示" title="心率动态显示"></p><p><img src="https://cdn.jsdelivr.net/gh/hehung/stm32-heart-rate-monitoring/img/Heart_rate_data.gif" alt="心率数据" title="心率数据"></p><h1 id="开发环境与开发器件"><a href="#开发环境与开发器件" class="headerlink" title="开发环境与开发器件"></a>开发环境与开发器件</h1><p>　　开发环境：<br>　　1、win10 +MDK keil5.24<br>　　２、ST-LINK下载器（不一定需要这个，J-LINK和串口下载都是可以的）</p><p>　　我是用的是STM32F103C8T6最小系统板，价格比较便宜并且功能足够强大。<br>　　元器件有：<br>　　==&gt;pulse sensor心率传感器<br>　　==&gt;IIC OLED显示屏<br>　　==&gt;按键2个<br>　　==&gt;LED1个<br>　　==&gt;蜂鸣器1个</p><h1 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h1><p>　　在硬件结构方面还是比较简单的，连线比较简单，就是在软件方面花费了我一些时间，算法处理和波形系那是还是花了一些时间采写好的。<br>　　放上电路连接图：<br><img src="https://cdn.jsdelivr.net/gh/hehung/stm32-heart-rate-monitoring/img/Schematic.jpg" alt="电路图" title="电路图"></p><h1 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h1><h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><p>　　OLED方面我采用的是IIC操作的OLED，因为IIC操作简单，只需要两根线（我直接使用的PA7和PA8）。使用了软件IIC，直接移植的正点原子的官方例程的IIC，OLED显示也是移植的正点原子的程序，只是做了改进，可以显示汉字（正点原子的官方例程中OLED程序不能显示汉字，我对代码进行升级，可以显示汉字），还增加了自动在数字前面补0的功能。</p><p>　　由于程序比较大，这里只放了重点的代码，在后面也提供源码。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//OLED波形显示函数</span><span class="token keyword">void</span> <span class="token function">OLED_Waveform_display</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>                u8 n<span class="token punctuation">;</span>        <span class="token function">IF</span><span class="token punctuation">(</span>waveform_flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>                waveform_flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">127</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span><span class="token number">64</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token function">OLED_DrawPoint</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//波形线补点操作，如果不用，可以注释掉,将#if 1改为#if 0</span>                        <span class="token comment" spellcheck="true">//引用波形补点函数可以是波形看起来是连续的</span>                        <span class="token macro property">#<span class="token directive keyword">if</span> 1</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>                        <span class="token punctuation">{</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">myabs</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>waveform<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>waveform<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>                                <span class="token punctuation">{</span>                                        <span class="token keyword">if</span><span class="token punctuation">(</span>waveform <span class="token operator">></span> waveform<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                        <span class="token punctuation">{</span>                                                <span class="token keyword">for</span><span class="token punctuation">(</span>n<span class="token operator">=</span>waveform<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>waveform<span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span>                                                <span class="token punctuation">{</span>                                                        <span class="token function">OLED_DrawPoint</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//在相应的像素点上打印</span>                                                <span class="token punctuation">}</span>                                        <span class="token punctuation">}</span><span class="token keyword">else</span>                                        <span class="token punctuation">{</span>                                                <span class="token keyword">for</span><span class="token punctuation">(</span>n<span class="token operator">=</span>waveform<span class="token punctuation">;</span>n<span class="token operator">&lt;</span>waveform<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span>                                                <span class="token punctuation">{</span>                                                        <span class="token function">OLED_DrawPoint</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//在相应的像素点上打印</span>                                                <span class="token punctuation">}</span>                                        <span class="token punctuation">}</span>                                <span class="token punctuation">}</span>                                                <span class="token punctuation">}</span>                        <span class="token function">OLED_DrawPoint</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>waveform<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//在相应的像素点上打印</span>                        <span class="token macro property">#<span class="token directive keyword">endif</span></span>                <span class="token punctuation">}</span>                <span class="token function">OLED_Refresh_Gram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment" spellcheck="true">//更新显示到OLED</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pulse-sensor心率传感器"><a href="#pulse-sensor心率传感器" class="headerlink" title="pulse sensor心率传感器"></a>pulse sensor心率传感器</h2><p>　　pulse sensor心率传感器采用ADC进行数据采集，使用到了ADC0（PA0）。通过配置ADC引脚完成ADC的采集，通过实验，可以正常的采集到数据。当人的手指放上之后用示波器可以看到心跳的电压变化。</p><h3 id="操作说明书"><a href="#操作说明书" class="headerlink" title="操作说明书"></a>操作说明书</h3><p>　　说明书密码（xinghuidianzi）：<br>  Pulse Sensor使用说明书V5.5（密码xinghuidianzi）<br><a href="https://cdn.jsdelivr.net/gh/hehung/STM32-heart-rate-monitoring/doc/Pulse_Sensor使用说明书V5.5_密码xinghuidianzi.pdf" target="_blank" rel="noopener" title="点此处下载">点此处下载</a></p><h3 id="心率监测算法实现"><a href="#心率监测算法实现" class="headerlink" title="心率监测算法实现"></a>心率监测算法实现</h3><p>　　心率算法就是检测心率波形的峰值，检测到  有60000ms 除以两个峰值时间（ms）就是心率值，说起来比较简单，但是操作起来有各种干扰，通过官方的例程上进行修改，最终成功测出心率值，还是比较准确的</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//心率采集与计算处理</span><span class="token keyword">void</span> <span class="token function">HeartRate_deal</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> runningTotal<span class="token punctuation">;</span>        u8 i<span class="token punctuation">;</span>        Num <span class="token operator">=</span> sampleCounter <span class="token operator">-</span> lastBeattime<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//监控最后一次节拍后的时间，以避免噪声</span>        <span class="token comment" spellcheck="true">//找到脉冲波的波峰和波谷</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Signal <span class="token operator">&lt;</span> thresh <span class="token operator">&amp;&amp;</span> Num <span class="token operator">></span> <span class="token punctuation">(</span>IBI<span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//为了避免需要等待3/5个IBI的时间</span>        <span class="token punctuation">{</span>                       <span class="token keyword">if</span><span class="token punctuation">(</span>Signal <span class="token operator">&lt;</span> T<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                                                        <span class="token comment" spellcheck="true">//T是阈值</span>                        T <span class="token operator">=</span> Signal<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//跟踪脉搏波的最低点，改变阈值</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Signal <span class="token operator">></span> thresh <span class="token operator">&amp;&amp;</span> Signal <span class="token operator">></span> P<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//采样值大于阈值并且采样值大于峰值</span>        <span class="token punctuation">{</span>                          P <span class="token operator">=</span> Signal<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//P是峰值，改变峰值</span>        <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//现在开始寻找心跳节拍</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Num <span class="token operator">></span> <span class="token number">250</span><span class="token punctuation">)</span>                                <span class="token comment" spellcheck="true">//避免高频噪声</span>        <span class="token punctuation">{</span>                                                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Signal <span class="token operator">></span> thresh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>Pulse <span class="token operator">==</span> false<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>Num <span class="token operator">></span> <span class="token punctuation">(</span>IBI<span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                                Pulse <span class="token operator">=</span> true<span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//当有脉冲的时候就设置脉冲信号。</span><span class="token comment" spellcheck="true">//                                LED_ON();                                                                        //打开LED，表示已经有脉冲了</span>                        IBI <span class="token operator">=</span> sampleCounter <span class="token operator">-</span> lastBeatTime<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//测量节拍的ms级的时间</span>                        lastBeatTime <span class="token operator">=</span> sampleCounter<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//记录下一个脉冲的时间。</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>secondBeat<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//如果这是第二个节拍，如果secondBeat == TRUE，表示是第二个节拍</span>                        <span class="token punctuation">{</span>                                                        secondBeat <span class="token operator">=</span> false<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//清除secondBeat节拍标志</span>                                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//在启动时，种子的运行总数得到一个实现的BPM。</span>                                <span class="token punctuation">{</span>                                                     rate <span class="token operator">=</span> IBI<span class="token punctuation">;</span>                                                      <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>firstBeat<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">//如果这是第一次发现节拍，如果firstBeat == TRUE。</span>                        <span class="token punctuation">{</span>                                                         firstBeat <span class="token operator">=</span> false<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//清除firstBeat标志</span>                                secondBeat <span class="token operator">=</span> true<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//设置secongBeat标志</span>                                <span class="token keyword">return</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//IBI值是不可靠的，所以放弃它。</span>                        <span class="token punctuation">}</span>                           <span class="token comment" spellcheck="true">//保留最后10个IBI值的运行总数。</span>                        runningTotal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//清除runningTotal变量</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                                <span class="token comment" spellcheck="true">//转换数据到rate数组中</span>                        <span class="token punctuation">{</span>                                                rate <span class="token operator">=</span> rate<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//去掉旧的的IBI值。 </span>                                runningTotal <span class="token operator">+</span><span class="token operator">=</span> rate<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//添加9个以前的老的IBI值。</span>                        <span class="token punctuation">}</span>                        rate<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> IBI<span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//将最新的IBI添加到速率数组中。</span>                        runningTotal <span class="token operator">+</span><span class="token operator">=</span> rate<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//添加最新的IBI到runningTotal。</span>                        runningTotal <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//平均最后10个IBI值。</span>                        BPM <span class="token operator">=</span> <span class="token number">60000</span><span class="token operator">/</span>runningTotal<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//一分钟有多少拍。即心率BPM</span>                        QS <span class="token operator">=</span> true<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//设置量化自我标志Quantified Self标志</span>                        <span class="token comment" spellcheck="true">//在这个ISR（中断服务程序）中，QS标志没有被清除。</span>                <span class="token punctuation">}</span>                              <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Signal <span class="token operator">&lt;</span> thresh <span class="token operator">&amp;&amp;</span> Pulse <span class="token operator">==</span> true<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//当值下降时，节拍就结束了。</span>        <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//                        LED_OFF();                                                                //关闭LED</span>                Pulse <span class="token operator">=</span> false<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//重设脉冲标记，这样方便下一次的计数</span>                amp <span class="token operator">=</span> P <span class="token operator">-</span> T<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//得到脉冲波的振幅。</span>                thresh <span class="token operator">=</span> amp<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> T<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//设置thresh为振幅的50%。</span>                P <span class="token operator">=</span> thresh<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//重新设置下一个时间</span>                T <span class="token operator">=</span> thresh<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Num <span class="token operator">></span> <span class="token number">2500</span><span class="token punctuation">)</span>                                <span class="token comment" spellcheck="true">//如果2.5秒过去了还没有节拍</span>        <span class="token punctuation">{</span>                                           thresh <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>                          <span class="token comment" spellcheck="true">//设置默认阈值</span>                P <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//设置默认P值</span>                T <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//设置默认T值</span>                lastBeatTime <span class="token operator">=</span> sampleCounter<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//把最后的节拍跟上来。       </span>                firstBeat <span class="token operator">=</span> true<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//设置firstBeat为true方便下一次处理</span>                secondBeat <span class="token operator">=</span> false<span class="token punctuation">;</span>                            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　我将采集工作与算法处理都放在了定时器里面，初始化了一个2ms的定时器中断，这个工作都是每2ms进行一次</p><p>　　LED、按键和蜂鸣器就不用多说了，很简单，蜂鸣器需要一个三极管进行信号放大，不然的话是驱动不了的。<br>　　　　1、按下按键1，可以进行界面的切换，在界面1的时候回显示西女排的数据值，ADC值等信息。<br>　　　　2、在界面2的时候就是显示波形，在人的手没有放上的时候一般不会显示，手放上之后就会显示心率（人的手放上之后，芯片会有一段时间的空白期(采集到的数据为0)，我就是根据这段时间来判断时候有手放上）<br>　　　　3、当采集到的心率值不在规定的范围之内时蜂鸣器就会报警<br>　　　　4、按下按键2之后蜂鸣器停止报警，知道再次检测到人手放在传感器上面。</p><h1 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h1><p><img src="https://cdn.jsdelivr.net/gh/hehung/stm32-heart-rate-monitoring/img/Test.jpg" alt="测试" title="测试"></p><h1 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h1><p>　　我已经将代码都整理好了，可以在上面直接下载。<br>　　点击此处直接下载：<br><a href="https://cdn.jsdelivr.net/gh/hehung/STM32-heart-rate-monitoring/基于stm32的心率监控装置.zip" target="_blank" rel="noopener" title="点我下载">点我下载</a><br>　　<br>　　去github：<a href="https://github.com/hehung/STM32-heart-rate-monitoring" target="_blank" rel="noopener" title="点我去github">点我去github</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> STM32 </tag>
            
            <tag> OLED </tag>
            
            <tag> 心率监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客搭建好了</title>
      <link href="/2019/91e01a8d.html"/>
      <url>/2019/91e01a8d.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　很久之前就知道github，但是一直都只是听说，并没有接触过。最近<br>看到了一篇文章说可以使用github来搭建一个博客，处于想拥有一个个人博客的目的也来玩玩。听说博客是基于hexo来搭建的，所以在网上搜索了一下，按照了网友提供的方式下载相应的node.js和npm插件，搭建了本地环境，然后使用git部署到github和coding上。</p><h1 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h1><p>　　按照了hexo之后的默认主题太丑了，所以理所应当的是要换个主题，<br>在theme里面找了一圈，发现了现在用的这个主题比较炫酷，所以就采用了这个主题来作为我博客的主题了，哈哈哈哈😜。</p><p>　　最开始看到这个主题确实觉得太炫酷了。对于一个不会前端的人<br>而言，如果自己要做一个这样的主题肯定是不现实的，在这里感谢主题的开发者们了。</p><h1 id="之后呢"><a href="#之后呢" class="headerlink" title="之后呢"></a>之后呢</h1><p>　　有了自己的博客之后，当然就是进行一个多多在自己的博客上发表<br>文章了，我也会学习学习前端技术，争取能够自己改善这个主题的布局，变成一个属于自己的特殊的主题🤔。</p><p>好了，这是敌我的第一篇文章，就到这里了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
