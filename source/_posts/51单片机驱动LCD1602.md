---
title: 51单片机驱动LCD1602
date: 2019-11-23 16:34:30
tags: 
        - 单片机
        - C语言
        - LCD1602
autor: hehung
categories: 51单片机
img: https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/display3.jpg
cover: false
coverImg: https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/display3.jpg
top: false
summary: 使用51单片机完成对DS18B20的操作。DS18B20是一个单总线的温度采集芯片，能够学习DS18B20的应用。
---


>单片机中用到数据显示的时候使用LCD1602的时候还是挺多的，本文讲解了对LCD1602的使用操作。以前发帖在电子芯巴克。原帖子链接：[点我跳转](https://bbs.icxbk.com/thread-100298-1-1.html)

# 原理图

&emsp;&emsp;首先查看原理图。

![原理图](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/LCD1602.png "原理图")

&emsp;&emsp;从上面的原理图中可以看出，LCD1602是使用P0操作的，还有一个电位器可以用来调节显示亮度。

&emsp;&emsp;三个读/写时序操作引脚需要自己根据自己的实际情况连接，我是连接在下面三个引脚上的
+ rs ====> P2^6
+ rw====> P2^5
+ e  ====> P2^7

&emsp;&emsp;LCD1602在开发板上的显示如下所示：

![LCD1602](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/LCD1602_conect.png "LCD1602")

# LCD1602时序

## 写时序

&emsp;&emsp;写时序如下图所示：

![写时序图](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/Write_time_seq.png "写时序图")

&emsp;&emsp;首先要对寄存器的选择和读、写操作选择进行配置。
&emsp;&emsp;RS是寄存器选择，rs = 1对数据进行操作；rs = 0对指令进行操作。 
&emsp;&emsp;接着对读写操作选择进行配置，rw = 0 写操作。 
&emsp;&emsp;打开使能端，输入使能信号 e = 1。 
&emsp;&emsp;数据总线，对DB0~DB7（就是P0）赋值，进行数据的传输。

## 读时序

&emsp;&emsp;读时序如下图所示：

![读时序图](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/Read_time_seq.png "读时序图")

&emsp;&emsp;理解方式与上面写时序是一样的。


# 程序编写

&emsp;&emsp;知道了原理图，接下来就是写程序了。

``` C
 #include<reg52.h>
#define uchar unsigned char
#define uint unsigned int
sbit rs=P2^6;
sbit rw=P2^5;
sbit e=P2^7;

uchar xs1[]=" hello,welcome you! ";
uchar xs2[]="    I am happy!     ";

uchar table[]={0x01,0x03,0x07,0x08,0x1f,0x3f,0x7f,0xff};


void yan(uint ms)
{
     uint w;
         for(;ms>0;ms--)
            for(w=110;w>0;w--);
}
void xzl(uchar com)
{
     e=0;
     rs=0;
         rw=0;
         P0=com;
         yan(1);
         e=1;
         yan(2);
         e=0;
}
void xsj(uchar dat)
{
         e=0;
     rs=1;
         rw=0;
         P0=dat;
         yan(1);
         e=1;
         yan(2);
         e=0;
}
void init()
{
         xzl(0x38);
         xzl(0x08);
         xzl(0x01);
         xzl(0x06);
         xzl(0x0c);
} 
void main()
{
     uchar i;
     init();
         xzl(0x80+0x16);
         for(i=0;i<16;i++)
         {
             xsj(xs1[i]);                //显示第一行数据
                 yan(30);
         }
         xzl(0x80+0x40+0x16);
         for(i=0;i<16;i++)
         {
             xsj(xs2[i]);                //显示第二行数据
                 yan(30);
         }
          while(1)
          {
                 for(i=0;i<40;i++)
                 {
                      xzl(0x1c);                //右移命令
                          yan(300);
                 }          
          }                  
}
```

# 运行结果

&emsp;&emsp;写好了程序之后就是验证我们的实验结果了，由于使用了右移命令，所以文字连续向右移动，感兴趣的小伙伴可以试一下，如下图所示：

![运行结果](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/Display1.gif "运行结果")

![运行结果](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/display2.gif "运行结果")


# 附件

[点我下载LCD1602液晶完整中文资料](https://cdn.jsdelivr.net/gh/hehung/cdn-jsDelivr-hehung-blog-sources/51-LCD1602/LCD1602液晶完整中文资料.pdf)

